<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.54
     from gtk.texi on 24 March 1999 -->

<TITLE>GTK</TITLE>

</HEAD>
<BODY>
<H1>The GIMP Toolkit</H1>
<H2>Version 1.0</H2>
<H2>August 1998</H2>
<ADDRESS>by Peter Mattis and the GTK+ team</ADDRESS>
<P>
<P><HR><P>


<H1><A NAME="SEC1" HREF="gtk_toc.html#TOC1">Copying</A></H1>
<P>
<A NAME="IDX4"></A>

</P>
<P>
GTK is <STRONG>free</STRONG>; this means that everyone is free to use it and free
to redistribute it on a free basis. GTK is not in the public domain; it
is copyrighted and there are restrictions on its distribution, but
these restrictions are designed to permit everything that a good
cooperating citizen would want to do. What is not allowed is to try to
prevent others from further sharing any version of GTK that they might
get from you.

</P>
<P>
Specifically, we want to make sure that you have the right to give away
copies of GTK, that you receive source code or else can get it if you
want it, that you can change GTK or use pieces of it in new free
programs, and that you know you can do these things.

</P>
<P>
To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights. For example, if you distribute
copies of GTK, you must give the recipients all the rights that you
have. You must make sure that they, too, receive or can get the source
code. And you must tell them their rights.

</P>
<P>
Also, for our own protection, we must make certain that everyone finds
out that there is no warranty for GTK. If GTK is modified by someone
else and passed on, we want their recipients to know that what they have
is not what we distributed, so that any problems introduced by others
will no reflect on our reputation.

</P>
<P>
The precise conditions of the licenses for GTK are found in the General
Public Licenses that accompany it.

</P>



<H1><A NAME="SEC2" HREF="gtk_toc.html#TOC2">What is GTK?</A></H1>
<P>
<A NAME="IDX5"></A>

</P>
<P>
GTK is a library for creating graphical user interfaces similar to the
Motif "look and feel". It is designed to be small and efficient, but
still flexible enough to allow the programmer freedom in the interfaces
created. GTK allows the programmer to use a variety of standard user
interface widgets (see section <A HREF="gtk.html#SEC15">Widget Overview</A>) such as push, radio and check
buttons, menus, lists and frames. It also provides several "container"
widgets which can be used to control the layout of the user interface
elements.

</P>
<P>
GTK provides some unique features. (At least, I know of no other widget
library which provides them). For example, a button does not contain a
label, it contains a child widget, which in most instances will be a
label. However, the child widget can also be a pixmap, image or any
combination possible the programmer desires. This flexibility is adhered
to throughout the library.

</P>

<P>
To make life easier for you, GTK presents this flexibility in a uniform
framework.  Specifically, it implements its own support for object
oriented programming that is well adapted to the purposes of a user
interface toolkit and it aims at providing a reasonable sane and
disciplined programming interface.  This uniformity and discipline is
intended to make it easy and reliable to access GTK from languages other
than C.  Especially more dynamic languages like Perl, Python or Scheme
will find amble support, and in fact, bindings to these languages
already exist.

</P>


<H1><A NAME="SEC3" HREF="gtk_toc.html#TOC3">Types</A></H1>
<P>
<A NAME="IDX6"></A>
<A NAME="IDX7"></A>
<A NAME="IDX8"></A>

</P>

<PRE>
Other kid's games are all such a bore!
They've gotta have rules and they gotta keep score!
<BR>
-- Calvin about CalvinBall(tm)
</PRE>

<P>
GTK implements a semi-simple type system with an associated class
mechanism for widgets and several other useful objects.  This type
system is intended to be general enough to allow both a smooth binding
of dynamically typed languages to Gtk, as well as to serve for a
rigorous and formalistic definition of the larger part of the Gtk API.

</P>

<P>
The classes for the individual widgets are by far the most important
part of this type system, but before we get to them, we describe the
basics of the type system itself.  This is mostly of interest for widget
writers and language binders, so you might want to skip ahead to the
next chapter, which talks about the object oriented stuff.

</P>



<H2><A NAME="SEC4" HREF="gtk_toc.html#TOC4">Introduction to the Type System</A></H2>

<P>
Gtk defines its own system of types, much like a computer language
defines what types it supports.  Of course, the Gtk type system is build
on top of the types that C provides, so it includes members like
<SAMP>`int'</SAMP>, <SAMP>`long'</SAMP> and <SAMP>`float'</SAMP>.  But, compared to C, it allows
only few carefully selected types and specifies a lot of restrictions on
the way you can use values of these types.  For example, there is no
general facility for specifying <EM>pointer to X</EM>.  Instead, we take a
more higher level approach and define such things as <SAMP>`string'</SAMP>,
which is just like a <CODE>char*</CODE> but with additional rules about how to
manage the memory that it points to.

</P>
<P>
The type system has two purposes: to define a formal system with which
to describe the various exported features of Gtk; and to implement this
system at run-time so that we get sound and flexible <STRONG>dynamic</STRONG> types
for the dynamic languages that want to interface with Gtk.

</P>
<P>
Let me restate this with different words, because I think it is
important to understand this idea.  We will see in a moment that the
type system is indeed well defined and all this detail is implemented
with functions and data structures in Gtk.  For example, every type (and
there can be any number of them) can be represented with a unique
integer and Gtk has support for the necessary bookkeeping for this.
Every type also has a name and there are functions for converting
between the name of a type and its unique number.  Maybe more useful,
there is a big discriminated union that can be used to pass around a
value of any representable type, together with its precise type.

</P>
<P>
This is the run-time or dynamic side of the type system.  Mostly, you do
not need to use it when you don't want to.  The compile-time or static
side of the type system can is used to statically define the programming
interface of Gtk.  For example, suppose there is function <CODE>gtk_foo</CODE>
in the Gtk API that has a prototype

</P>

<PRE>
char *gtk_foo (char *);
</PRE>

<P>
This looks like it does something with strings.  But what does it do
with the memory of the string that has been passed in, and what are we
supposed or allowed to do with the memory that the returned pointer
points to?  The more restricted type <SAMP>`string'</SAMP> from the Gtk type
system can be used to be more precise.  In fact, the definition of
<SAMP>`string'</SAMP> below includes the rule that when a <SAMP>`string'</SAMP> is
passed to a function, that function is not allowed to retain a pointer
into the string beyond the life time of that function call.  So we are
safe to deallocate it or override it when the function has returned.
Likewise, the definition specifies that the memory of a <SAMP>`string'</SAMP>
that is returned from a function becomes the sole property of the
calling function.  The calling function is responsible for deallocating
it eventually and it can be sure that nobody else scribbles in it.  When
<SAMP>`gtk_foo'</SAMP> really obeys these rules, we can say that it takes one
argument, which is a <SAMP>`string'</SAMP>, and it returns a <SAMP>`string'</SAMP>.

</P>
<P>
Now we can understand why it makes sense to have a more restrictive type
system than that of C.  With it, it is possible to be more precise and
we actually have a framework where we can be sure that as long as we
stay inside this framework we are not gratuitously causing trouble for
languages that are more disciplined than C.  Of course, you are not
restricted to making all your interfaces expressible within the
framework.  There are valid reasons for breaking it, for performance or
simply for convenience.  But please try to provide all the functionality
of your module in such a way that it can be described with this type
system and treat the non-conforming functions as additional goodies that
are nice to have but not essential.  The reward is an instant
accessibility of your code from a huge number of scripting and extension
languages such as Perl, Python, and Guile.

</P>
<P>
These formal specifications of the Gtk interface are contained in
special declarations in the header files of Gtk.  They are ignored by
the C compiler, but can be used by other language processors.  For extra
convenience, these declarations are also available in a more condensed
form that is easier to parse.  Tools for generating bindings of Gtk to
other languages can read these declarations and--because all the
important details are defined--automatically generate the bulk of the
needed glue code.  It is also possible to feed these declarations into a
running application (a interface builder, say) and thus make it aware of
new widgets and functions without recompiling anything.

</P>
<P>
The run-time side of the type system is also somewhat introspective.
This means that you can query Gtk about all the members of an
enumeration for example.  Gtk provides tools that help you provide this
introspection for your definitions also.

</P>
<P>
Types are not enough to completely specify an interface, so GTK also has
<STRONG>modes</STRONG>.  A mode specifies what happens to a value when it crosses a
module boundary; it can be <SAMP>`in'</SAMP>, <SAMP>`out'</SAMP>, or <SAMP>`inout'</SAMP>.  Most
fundamental types (and their derived types) support only mode <SAMP>`in'</SAMP>.
The modes <SAMP>`out'</SAMP> and <SAMP>`inout'</SAMP> can only be used with the
composite types: lists and vectors.  When argument of these types are
marked as <SAMP>`out'</SAMP> or <SAMP>`inout'</SAMP> it means that the called module is
allowed to change the contents of the composite value and that these
changes need to be propagated back to the originator of the value.  Mode
<SAMP>`out'</SAMP> means that the argument has no meaningful value at the
beginning and should not be read.  Mode <SAMP>`in'</SAMP> specifies that the
called module is not allowed to change the value in any way.

</P>
<P>
The type system allows for an unbounded number of types.  Every widget
is a type for example and you can add new widget types at any time
without confusing the run-time implementation of the type system.
Nevertheless, all types are derived from a certain <STRONG>fundamental</STRONG>
type, and there are only a small and finite number of fundamental types.
We only specify rules for the fundamental types and all other types
inherit these rules from their fundamental type.  For example,
<SAMP>`int'</SAMP> is a fundamental type, as is <SAMP>`GtkObject'</SAMP>.  All widgets
derive from <SAMP>`GtkObject'</SAMP> and so the rules for <SAMP>`GtkObject'</SAMP> apply
to all widgets as well.

</P>
<P>
This derivation defines a type hierachy, but this hierachy is not
completely general.  You can't derive from <SAMP>`int'</SAMP> for example, and
you can only have one level of derivation from <SAMP>`enum'</SAMP>.  The
fundamental type <SAMP>`GtkObject'</SAMP>, however, is the basis for the large
and deep hierarchy of widget types.

</P>
<P>
The individual fundamental types are defined and explained in the
following sections.  Here is a complete list of them:

</P>
<DL COMPACT>

<DT><SAMP>`none'</SAMP>
<DD>
The not-a-value type, similar to <SAMP>`void'</SAMP>.
<DT><SAMP>`char'</SAMP>
<DD>
A character.  Internationalization issues are still undecided.
<DT><SAMP>`bool'</SAMP>
<DD>
True or false.
<DT><SAMP>`byte, ubyte, int, uint, long, ulong, float, double'</SAMP>
<DD>
The usual assortment of scalar types.
<DT><SAMP>`string'</SAMP>
<DD>
A string.  Internationalization issues are still undecided.
<DT><SAMP>`enum, flags'</SAMP>
<DD>
Enumerations with a fixed set of literals.  Either used to express a
single choice from this set or to individually turn on and off several
flags.
<DT><SAMP>`boxed'</SAMP>
<DD>
A pointer to an opaque structure that can be copied and destroyed.
<DT><SAMP>`callback'</SAMP>
<DD>
A pointer to a function with enough extra information so that it can
also be used for functions written in languages completely different
from C.
<DT><SAMP>`GtkObject'</SAMP>
<DD>
A pointer to a GtkObject or derived type.  The fun starts here.
<DT><SAMP>`args, slist, dlist, cvec, tvec'</SAMP>
<DD>
An assortment of composite types like linked lists and counted or
zero-terminated arrays.
<DT><SAMP>`pointer, signal, c_callback'</SAMP>
<DD>
Obsolete types.
</DL>



<H2><A NAME="SEC5" HREF="gtk_toc.html#TOC5">Basic Concepts</A></H2>

<P>
The basis for the type system are the fundamental types.  At run-time,
they are represented by members of the <CODE>GtkFundamentalType</CODE>
enumeration.  For the static declarations, they are identified with a
unique name.

</P>
<P>
<DL>
<DT><U>Enumeration:</U> <B>GtkFundamentalType</B>
<DD><A NAME="IDX9"></A>
This enumeration contains a member for each defined fundamental type.
Most members are listed along with the description of their semantics,
but one is listed here:

</P>
<DL COMPACT>

<DT><CODE>GTK_TYPE_INVALID</CODE>
<DD>
No valid type is derived from this.  Use <CODE>GTK_TYPE_INVALID</CODE> to
express exceptional situations.  This member does not really correspond
to a fundamental type and thus there is no name for it.
</DL>
</DL>

<P>
<DL>
<DT><U>Data type:</U> <B>GtkType</B>
<DD><A NAME="IDX10"></A>
The type <CODE>GtkType</CODE> holds the run-time representation of a type.  It
is a integer of a certain size.  The follwing macros are defined to
access the basic properties of a <CODE>GtkType</CODE>:

</P>
<P>
<DL>
<DT><U>Macro:</U> unsigned int <B>GTK_TYPE_SEQNO</B> <I>(GtkType type)</I>
<DD><A NAME="IDX11"></A>
Returns the sequence number of <VAR>type</VAR>.  The sequence numbers are
guaranteed to be dense, i.e., you can use them to index a table and the
table need not be much larger than the number of different GtkTypes that
you might encounter.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> GtkFundamentalType <B>GTK_FUNDAMENTAL_TYPE</B> <I>(GtkType type)</I>
<DD><A NAME="IDX12"></A>
Returns the fundamental type of <VAR>type</VAR>.
</DL>

</P>
<P>
Both macros simply access different bit-fields of a <CODE>GtkType</CODE>, so
they are very efficient.
</DL>

</P>
<P>
New types are registered with the <CODE>gtk_type_unique</CODE> function.  Any
kind oftype can be registered with <CODE>gtk_type_unique</CODE> but there are
convenience functions for most fundamental types.  Each fundamental type
has its own interpretation of the rules below and these convenience
functions should be used to automatically get the type registration
right.  So, don't be put off by the apparent complexity of the interface
to <CODE>gtk_type_unique</CODE>.  You will be using it only for new widgets,
and there the rules are simple.

</P>
<P>
The <CODE>GtkTypeInfo</CODE> structure is used to communicate information to
<CODE>gtk_type_unique</CODE> as opposed to passing in large numbers of
parameters.

</P>

<PRE>
typedef struct _GtkTypeInfo GtkTypeInfo;

struct _GtkTypeInfo
{
  gchar *type_name;
  guint object_size;
  guint class_size;
  GtkClassInitFunc class_init_func;
  GtkObjectInitFunc object_init_func;
  gpointer reserved_1;
  gpointer reserved_2;
  GtkClassInitFunc base_class_init_func;
}
</PRE>


<UL>
<LI>

The <CODE>type_name</CODE> field refers to the name of the type.  This is the
same name that is used in the static definitions.  It is convention for
the type name to be closely related to the name of the underlying C
type. For example, the type name of the <CODE>GtkObject</CODE> structure is
"GtkObject", and the name of the <CODE>GtkWindowType</CODE> enumeration is
"GtkWindowType".  Note that the C type corresponding to "GtkObject"
is really a pointer to a <CODE>GtkObject</CODE> struct, but the name has no
"*" in it.

<LI>

The <CODE>object_size</CODE> field refers to the size in bytes of the C
structure for types that have such a structure. The easiest (and
portable) means of computing this size is by using the C <CODE>sizeof</CODE>
operator. For instance, the sizeof of the <CODE>GtkObject</CODE> structure is
computed by doing <CODE>sizeof (GtkObject)</CODE>.  When the type has no
associated structure or when you do not want to support the
<CODE>gtk_type_new</CODE> function for the new type, set <CODE>object_size</CODE> to
0.  Only types derived from GTK_TYPE_OBJECT can be handled by
<CODE>gtk_type_new</CODE>, anyway.

<LI>

The <CODE>class_size</CODE> field refers to the size in bytes of the C
structure for the class.  Again, the <CODE>sizeof</CODE> operator should be
used to compute this value.  If you don't want to have a class structure
for this type, set the field to 0.  <CODE>gtk_type_class</CODE> will then
always return <CODE>NULL</CODE>.

<LI>

The <CODE>class_init_func</CODE> and <CODE>base_class_init_func</CODE> fields are
callbacks which are used by the type mechanism to initialize class
specific fields. The single argument these function taks is a pointer to
a class structure.  When you do not need one or both of them, set the
corresponding field to <CODE>NULL</CODE>.  The <CODE>class_init_func</CODE> will be
called at most once, right after the class structure of size
<CODE>class_size</CODE> has been allocated.  The interaction between
<CODE>class_init_func</CODE> and <CODE>base_class_init_func</CODE> is only really
useful for the full-fledged object system.  It is described there
see section <A HREF="gtk.html#SEC12">Objects</A>.

<LI>

The <CODE>object_init_func</CODE> field is a callback which is used by the
type mechanism to initialize object specific fields for structures that
have been allocated via <CODE>gtk_type_new</CODE>. The single argument this
functions takes is a pointer to an object structure.  If you do not want
any special object initialization to take place, set this to
<CODE>NULL</CODE>.  All object initialization functions for all types that are
part of the inheritance chain are called, starting with the most basic
type.

</UL>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_type_unique</B> <I>(GtkType <VAR>parent_type</VAR>, GtkTypeInfo *<VAR>type_info</VAR>)</I>
<DD><A NAME="IDX13"></A>
The <VAR>parent_type</VAR> is simply the new types parent type. If
<VAR>parent_type</VAR> is GTK_TYPE_INVALID, then the new type is a new
fundamental type.  You should <B>never</B> register new fundamental types.
<VAR>type_info</VAR> is a pointer to a structure which contains necessary
information for construction of the new type.

</P>
<P>
You can only register a specific name once.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gchar* <B>gtk_type_name</B> <I>(GtkType <VAR>type</VAR>)</I>
<DD><A NAME="IDX14"></A>
The returned string is the name of <VAR>type</VAR> as specified to
<CODE>gtk_type_unique</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkType <B>gtk_type_from_name</B> <I>(guchar *<VAR>name</VAR>)</I>
<DD><A NAME="IDX15"></A>
Return the type associated with <VAR>name</VAR>. If there is no type
associated with <VAR>name</VAR>, then GTK_TYPE_INVALID will be returned.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkType <B>gtk_type_parent</B> <I>(GtkType <VAR>type</VAR>)</I>
<DD><A NAME="IDX16"></A>
Returns the parent type of <VAR>type</VAR> or GTK_TYPE_INVALID if <VAR>type</VAR>
is a fundamental type.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gpointer <B>gtk_type_class</B> <I>(GtkType <VAR>type</VAR>)</I>
<DD><A NAME="IDX17"></A>
Returns the initialized class structure for <VAR>type</VAR>. The class
structure is actually created and initialized the first time it is
needed.  Refer to see section <A HREF="gtk.html#SEC12">Objects</A> for details on how this initialization works for GTK_TYPE_OBJECT derived types.

</P>

<P>
The returned structure is shared by all objects of <VAR>type</VAR> and, as
such, should not be modified.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gpointer <B>gtk_type_new</B> <I>(GtkType <VAR>type</VAR>)</I>
<DD><A NAME="IDX18"></A>
Returns a new instance of an <VAR>type</VAR> object.  This works only for GTK_TYPE_OBJECT derived types.  Please see see section <A HREF="gtk.html#SEC12">Objects</A>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_type_describe_heritage</B> <I>(GtkType <VAR>type</VAR>)</I>
<DD><A NAME="IDX19"></A>
Prints the type heritage for <VAR>type</VAR>. The heritage for a type
includes the type and all its parent types up the type tree.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_type_describe_tree</B> <I>(GtkType <VAR>type</VAR>, gboolean <VAR>show_size</VAR>)</I>
<DD><A NAME="IDX20"></A>
Prints the type tree which starts at <VAR>type</VAR>. <VAR>show_size</VAR> is a
boolean which determines whether type sizes are printed.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gboolean <B>gtk_type_is_a</B> <I>(GtkType <VAR>type</VAR>, GtkType <VAR>is_a_type</VAR>)</I>
<DD><A NAME="IDX21"></A>
A predicate function which determines whether the relation <VAR>type</VAR>
is_a <VAR>is_a_type</VAR> is true.
</DL>

</P>

<P>
Values of all types can be handled uniformly by storing them into a
<CODE>GtkArg</CODE> structure.  The <CODE>GtkArg</CODE> has the following fields:

</P>
<DL COMPACT>

<DT><CODE>gchar *name</CODE>
<DD>
This can be used to give the value represented by this <CODE>GtkArg</CODE>
structure a name.  It is not used much.

<DT><CODE>GtkType type</CODE>
<DD>
The type of this value.

<DT><CODE>union d</CODE>
<DD>
A big union that has (at least conceptually) one member for each
fundamental type.  You should not access these members directly.
Rather, use the <CODE>GTK_VALUE_*</CODE> macros.  There is one macro for each
fundamental type, and its name is derived from the name of the
GtkFundamentalType enumeration members simply by replacing "Gtk_TYPE"
with "GTK_VALUE".  All <CODE>GTK_VALUE_*</CODE> macros take a <CODE>GtkArg</CODE>
structure as their only parameter (<EM>not</EM> a pointer) and evaluate to
a lvalue.
</DL>

<P>
For example, the accessor for the fundamental type GTK_TYPE_INT is
called GTK_VALUE_INT and you could use it like this:

</P>

<PRE>
GtkArg value;

value.name = NULL;
value.type = GTK_TYPE_INT;
GTK_VALUE_INT(value) = 7;
</PRE>



<H2><A NAME="SEC6" HREF="gtk_toc.html#TOC6">Simple Types</A></H2>

<P>
The Gtk type system has a full set of the usual simple types: integers,
floating point numbers, but also boolean and character.  You can not
derive new types from these.

</P>
<TABLE>

<TR>Enum <TD> Name <TD> Description
<BR>
<TR>GTK_TYPE_NONE <TD> "void"
<TD> A type without value.
<BR>
<TR>GTK_TYPE_CHAR <TD> "char"
<TD> A 8-bit unsigned number representing a character.  Numbers
     between 0 and 127 are ASCII, the rest is undefined.
<BR>
<TR>GTK_TYPE_BOOL <TD> "gboolean"
<TD> The boolean type.  It is some small integer where the number 0
     represents false and 1 is true.  No other values are allowed.
<BR>
<TR>GTK_TYPE_INT <TD> "gint"
<TD> A signed integer with at least 32 bits.
<BR>
<TR>GTK_TYPE_UINT <TD> "guint"
<TD> A unsigned integer with at least 32 bits.
<BR>
<TR>GTK_TYPE_LONG <TD> "glong"
<TD> A signed integer with at least 32 bits.
<BR>
<TR>GTK_TYPE_ULONG <TD> "gulong"
<TD> A unsigned integer with at least 32 bits.  This is large enough to
     hold a coerced pointer.
<BR>
<TR>GTK_TYPE_FLOAT <TD> "gfloat"
<TD> A single precision floating point number.
<BR>
<TR>GTK_TYPE_DOUBLE <TD> "gfloat"
<TD> A souble precision floating point number.
<BR>
<TR>GTK_TYPE_POINTER <TD> "gpointer"
<TD> A untyped pointer.  Do not use this if you can avoid it.
</TABLE>

The values of these types are all represented `directly' with the C
types that are indicated in the `name' column above.  see section <A HREF="gtk.html#SEC9">Boxed Types</A> for a discussion of this.



<H2><A NAME="SEC7" HREF="gtk_toc.html#TOC7">Enumerations and Flags</A></H2>



<H2><A NAME="SEC8" HREF="gtk_toc.html#TOC8">Strings</A></H2>



<H2><A NAME="SEC9" HREF="gtk_toc.html#TOC9">Boxed Types</A></H2>



<H2><A NAME="SEC10" HREF="gtk_toc.html#TOC10">Callbacks</A></H2>



<H2><A NAME="SEC11" HREF="gtk_toc.html#TOC11">Composite Types</A></H2>



<H1><A NAME="SEC12" HREF="gtk_toc.html#TOC12">Objects</A></H1>



<H2><A NAME="SEC13" HREF="gtk_toc.html#TOC13">Object functions</A></H2>

<P>
The GtkObject type is the root of the type hierarchy used by GTK. It
provides a minimal set of fields used to implement the actual object,
class and signal mechanisms, as well as several utility routines which
make dealing with objects easier.

</P>
<P>
For the adventurous, see section <A HREF="gtk.html#SEC414">Object internals</A>.

</P>
<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_object_get_type</B> <I>(void)</I>
<DD><A NAME="IDX22"></A>
Returns the <CODE>GtkObject</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_object_class_add_signals</B> <I>(GtkObjectClass *<VAR>class</VAR>, gint *<VAR>signals</VAR>, gint <VAR>nsignals</VAR>)</I>
<DD><A NAME="IDX23"></A>
Adds <VAR>signals</VAR> to the <CODE>signals</CODE> field in the GtkObjectClass
structure <VAR>class</VAR>. See section <A HREF="gtk.html#SEC14">Signals Overview</A>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkObject* <B>gtk_object_new</B> <I>(guint <VAR>type</VAR>, ...)</I>
<DD><A NAME="IDX24"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkObject* <B>gtk_object_newv</B> <I>(guint <VAR>type</VAR>, guint <VAR>nargs</VAR>, GtkArg *<VAR>args</VAR>)</I>
<DD><A NAME="IDX25"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_object_ref</B> <I>(GtkObject *<VAR>object</VAR>);</I>
<DD><A NAME="IDX26"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_object_unref</B> <I>(GtkObject *<VAR>object</VAR>);</I>
<DD><A NAME="IDX27"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_object_getv</B> <I>(GtkObject *<VAR>object</VAR>, guint <VAR>nargs</VAR>, GtkArg *<VAR>args</VAR>)</I>
<DD><A NAME="IDX28"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_object_set</B> <I>(GtkObject *<VAR>object</VAR>, ...)</I>
<DD><A NAME="IDX29"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_object_setv</B> <I>(GtkObject *<VAR>object</VAR>, guint <VAR>nargs</VAR>, GtkArg *<VAR>args</VAR>)</I>
<DD><A NAME="IDX30"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkArg* <B>gtk_object_query_args</B> <I>(GtkType <VAR>class_type</VAR>, guint *<VAR>nargs</VAR>)</I>
<DD><A NAME="IDX31"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_object_add_arg_type</B> <I>(gchar *<VAR>arg_name</VAR>, GtkType <VAR>arg_type</VAR>, guint <VAR>arg_id</VAR>)</I>
<DD><A NAME="IDX32"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkType <B>gtk_object_get_arg_type</B> <I>(gchar *<VAR>arg_name</VAR>)</I>
<DD><A NAME="IDX33"></A>
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> void <B>gtk_object_destroy</B> <I>(GtkObject *<VAR>object</VAR>)</I>
<DD><A NAME="IDX34"></A>
Performs checks to make sure it is alright to destroy <VAR>object</VAR> and
then emits the <CODE>destroy</CODE> signal. The check which is performed is to
make sure <VAR>object</VAR> is not already processing another signal. If this
were the case then destroying the object immediately would undoubtedly
cause problems as the other signal would not be able to tell the object
was destroyed. The solution is that if <VAR>object</VAR> is processing another
signal we mark <VAR>object</VAR> is needing to be destroyed. When we finish
processing of the other signal we check whether the object needs to be
destroyed.
</DL>

</P>
<P>
The GtkObject type provides a mechanism for associating arbitrary
amounts of data with an object. The data is associated with the object
using a character string key. The functions <CODE>gtk_object_set_data</CODE>,
<CODE>gtk_object_get_data</CODE>, and <CODE>gtk_object_remove_data</CODE> are the
interface to this mechanism. Two other routines,
<CODE>gtk_object_set_user_data</CODE> and <CODE>gtk_object_get_user_data</CODE>,
exist as convenience functions which simply use the same mechanism.

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_object_set_data</B> <I>(GtkObject *<VAR>object</VAR>, const char *<VAR>key</VAR>, gpointer <VAR>data</VAR>)</I>
<DD><A NAME="IDX35"></A>
Associate <VAR>data</VAR> with <VAR>key</VAR> in the data list of <VAR>object</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gpointer <B>gtk_object_get_data</B> <I>(GtkObject *<VAR>object</VAR>, const char *<VAR>key</VAR>)</I>
<DD><A NAME="IDX36"></A>
Retrieve the data associated with <VAR>key</VAR> in the data list of <VAR>object</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_object_remove_data</B> <I>(GtkObject *<VAR>object</VAR>, const char *<VAR>key</VAR>)</I>
<DD><A NAME="IDX37"></A>
Remove the data associated with <VAR>key</VAR> in the data list of <VAR>object</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_object_set_user_data</B> <I>(GtkObject *<VAR>object</VAR>, gpointer <VAR>data</VAR>)</I>
<DD><A NAME="IDX38"></A>
Sets <VAR>data</VAR> into the <CODE>user_data</CODE> field of <VAR>object</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gpointer <B>gtk_object_get_user_data</B> <I>(GtkObject *<VAR>object</VAR>)</I>
<DD><A NAME="IDX39"></A>
Returns the <CODE>user_data</CODE> field of <VAR>object</VAR>.
</DL>

</P>

<P>
The GtkObject type also provides a mechanism for specifying
initialization values for fields. This general mechanism is called
object value stacks. The reason for using value stacks is that they can
simplify the life of the programmer. For instance, by default widgets
are non-visible when created. However, the "visible" value for widgets
may be specified so that widgets are made visible when created. (FIXME:
unfinished).

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_object_value_stack_new</B> <I>(guint <VAR>object_type</VAR>, const gchar *<VAR>value_id</VAR>, GtkParamType <VAR>value_type</VAR>)</I>
<DD><A NAME="IDX40"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_object_push_value</B> <I>(guint <VAR>object_type</VAR>, const gchar *<VAR>value_id</VAR>, ...)</I>
<DD><A NAME="IDX41"></A>
Push a value on the value stack specified by <VAR>object_type</VAR> and
<VAR>value_id</VAR>. The type of value is implicitly given in the context of
<VAR>object_type</VAR> and <VAR>value_id</VAR>. (That is, it is not specified
explicitly in the function call). Only a single extra argument is
expected which is the data which is to be placed on the stack.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_object_pop_value</B> <I>(guint <VAR>object_type</VAR>, const gchar *<VAR>value_id</VAR>)</I>
<DD><A NAME="IDX42"></A>
Pop a value of the value stack specified by <VAR>object_type</VAR> and
<VAR>value_id</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_object_peek_value</B> <I>(guint <VAR>object_type</VAR>, const gchar *<VAR>value_id</VAR>, gpointer <VAR>data</VAR>)</I>
<DD><A NAME="IDX43"></A>
Peek at the value on the top of the value stack specified by
<VAR>object_type</VAR> and <VAR>value_id</VAR>. The <VAR>data</VAR> argument is
interpreted as the location of where to place the "peeked" data. For
instance, if the peeked data is of type <CODE>GTK_PARAM_POINTER</CODE>, then
<VAR>data</VAR> will be a pointer to a pointer. If the value stack is empty
or does not exist or an error occurs, <CODE>gtk_object_peek_value</CODE> will
return <CODE>FALSE</CODE>. On success it will return <CODE>TRUE</CODE>.
</DL>

</P>



<H1><A NAME="SEC14" HREF="gtk_toc.html#TOC14">Signals Overview</A></H1>
<P>
<A NAME="IDX44"></A>

</P>
<P>
Signals are GTK's method for objects to perform callbacks. A signal is
an event which occurs upon an object. The programmer can connect to a
signal of an object which involves specifying a function to be called
when that signal is emitted in the specified object.

</P>
<P>
When a signal is emitted, both the class function associated with the
signal (when it was defined) and all signal handlers installed for that
signal on the particular object emitting the signal are called. The
widget programmer can specify whether the class function is to be called
before after or both before and after the signal handlers installed by
the widget user. The widget user can, however, specify that their signal
handler is to be run after the class function (using the "_after"
signal connection routines). Any signal handling function can emit the
same signal on the same object while it is running causing that signal
emission to either restart or to run recursively. Additionally, signal
emission can be terminated prematurely. While both such abilities are
rarely used, they do allow for greater flexibility in regards to
signals. For instance, a programmer can attach to the key press event
signal and intercept all tab key presses from a widget. This particular
example is used in the file selection dialog to implement tab completion
of filenames and prevent the entry widget from inserting the tab into
its buffer.

</P>
<P>
Signals are selected using either an integer identifier or a character
string name. It is convention to name the signal the same as the class
function which is associated with it. There are two versions of most of
the signal functions, one which takes an integer identifier and one
which takes a character string name for the signal.

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_signal_new</B> <I>(gchar *<VAR>name</VAR>, GtkSignalRunType <VAR>run_type</VAR>, gint <VAR>object_type</VAR>, gint <VAR>function_offset</VAR>, GtkSignalMarshaller <VAR>marshaller</VAR>, GtkParamType <VAR>return_val</VAR>, gint <VAR>nparams</VAR>, ...)</I>
<DD><A NAME="IDX45"></A>
Create a new signal and give it the character string identifier
<VAR>name</VAR>. <VAR>name</VAR> needs to be unique in the context of
<VAR>object_type</VAR>'s branch of the class hierarchy. That is,
<VAR>object_type</VAR> cannot create a signal type with the same name as a
signal type created by one of its parent types.

</P>
<P>
<VAR>run_type</VAR> specifies whether the class function should be run before
(<CODE>GTK_RUN_FIRST</CODE>), after (<CODE>GTK_RUN_LAST</CODE>) or both before and
after normal signal handlers (<CODE>GTK_RUN_BOTH</CODE>). Additionally, the
<CODE>GTK_RUN_NO_RECURSE</CODE> value can be or'ed with any of those values to
specify that the signal should not be recursive. By default, emitting
the same signal on the same widget will cause the signal to be emitted
twice. However, if the <CODE>GTK_RUN_NO_RECURSE</CODE> flag is specified,
emitting the same signal on the same widget will cause the current
signal emission to be restarted. This allows the widget programmer to
specify the semantics of signal emission on a per signal
basis. (The <CODE>GTK_RUN_NO_RECURSE</CODE> flag is used by the GtkAdjustment
widget).

</P>
<P>
The <VAR>function_offset</VAR> is the byte offset from the start of the class
structure to the class function field within the class structure. The
easiest means to compute this offset is by using the
<CODE>GTK_SIGNAL_OFFSET</CODE> macro which takes the class structure type as
the first argument and the field as the second argument. For example,
<CODE>GTK_SIGNAL_OFFSET (GtkObjectClass, destroy)</CODE> will give the offset
of the <CODE>destroy</CODE> class function within the
<CODE>GtkObjectClass</CODE>. Note: An offset is specified instead of an
absolute location since there will be multiple instances of a class
structure being referenced. (The <CODE>GtkWidgetClass</CODE> structure "is
a" <CODE>GtkObjectClass</CODE> structure, etc.)

</P>
<P>
The <VAR>marshaller</VAR> function is used to invoke a signal handler. Since
signal handlers may take different parameters and return values and a
general mechanism for invoking them is not apparent, the approach of
making the signal creator responsible for invoking the signal handler
was taken. (FIXME: unfinished).

</P>
<P>
The <VAR>return_val</VAR> and <VAR>nparams</VAR> and the remaining arguments
specify the return value and the arguments to the signal handler
respectively. Note: There is an implicit first argument to every signal
handler which is the widget the signal has been emitted from. The
variable argument list (<VAR>...</VAR>) specifies the types of the
arguments. These can be one of <CODE>GTK_PARAM_CHAR</CODE>,
<CODE>GTK_PARAM_SHORT</CODE>, <CODE>GTK_PARAM_INT</CODE>, <CODE>GTK_PARAM_LONG</CODE>,
<CODE>GTK_PARAM_POINTER</CODE> or <CODE>GTK_PARAM_FUNCTION</CODE>. It is undefined
to specify <CODE>GTK_PARAM_NONE</CODE> as an argument type, however it is OK
to use <CODE>GTK_PARAM_NONE</CODE> for <VAR>return_val</VAR>. (This corresponds to
returning a <CODE>void</CODE>).

</P>
<P>
<CODE>gtk_signal_new</CODE> returns the integer identifier of the newly
created signal. Signal identifiers start numbering at 1 and increase
upwards. A value of -1 will be returned if an error occurs.

</P>
<P>
<STRONG>Note:</STRONG> <CODE>gtk_signal_new</CODE> is only needed by widget writers. A
normal user of GTK will never needed to invoke this function.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_signal_lookup</B> <I>(gchar *<VAR>name</VAR>, gint <VAR>object_type</VAR>)</I>
<DD><A NAME="IDX46"></A>
Returns the integer identifier for the signal referenced by <VAR>name</VAR>
and <VAR>object_type</VAR>. If <VAR>object_type</VAR> does not define the signal
<VAR>name</VAR>, then the signal is looked for in <VAR>object_type</VAR>'s parent
type recursively.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gchar* <B>gtk_signal_name</B> <I>(gint <VAR>signal_num</VAR>)</I>
<DD><A NAME="IDX47"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_signal_emit</B> <I>(GtkObject *<VAR>object</VAR>, gint <VAR>signal_type</VAR>, ...)</I>
<DD><A NAME="IDX48"></A>
Emit the signal specified by the integer identifier <VAR>signal_type</VAR>
from <VAR>object</VAR>. If an error occurs, <CODE>gtk_signal_emit</CODE> will
return <CODE>FALSE</CODE> and will return <CODE>TRUE</CODE> on success. The signal
definition determines the parameters passed in the variable argument
list (<CODE>...</CODE>). For example, if the signal is defined as:

</P>

<PRE>
  gint (* event) (GtkWidget *widget, GdkEvent *event);
</PRE>

<P>
Then a call to emit the "event" signal would look like:

</P>

<PRE>
  GdkEvent event;
  gint return_val;
  ...
  gtk_signal_emit (some_object,
                   gtk_signal_lookup ("event",
                     GTK_OBJECT_TYPE (some_object)),
                   &#38;event, &#38;return_val);
</PRE>

<P>
Notice that the <CODE>widget</CODE> argument is implicit in that the first
argument to every signal is a type derived from <CODE>GtkObject</CODE>. The
<VAR>return_val</VAR> argument is actually a pointer to the return value type
since the signal mechanism needs to be able to place the return value in
an actual location. And lastly, the <CODE>gtk_signal_lookup</CODE> call is
normally avoided by using the <CODE>gtk_signal_emit_by_name</CODE> function
instead. <CODE>gtk_signal_emit</CODE> is normally used internally by widgets
which know the signal identifier (since they defined the signal) and can
therefore side-step the cost of calling <CODE>gtk_signal_lookup</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_signal_emit_by_name</B> <I>(GtkObject *<VAR>object</VAR>, gchar *<VAR>name</VAR>, ...)</I>
<DD><A NAME="IDX49"></A>
Similar to <CODE>gtk_signal_emit</CODE> except that the signal is referenced
by <VAR>name</VAR> instead of by its integer identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_signal_emit_stop</B> <I>(GtkObject *<VAR>object</VAR>, gint <VAR>signal_type</VAR>)</I>
<DD><A NAME="IDX50"></A>
Stop the emission of the signal <VAR>signal_type</VAR> on
<VAR>object</VAR>. <VAR>signal_type</VAR> is the integer identifier for the signal
and can be determined using the function
<CODE>gtk_signal_lookup</CODE>. Alternatively, the function
<CODE>gtk_signal_emit_stop_by_name</CODE> can be used to refer to the signal
by name. Attempting to stop the emission of a signal that isn't being
emitted does nothing.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_signal_emit_stop_by_name</B> <I>(GtkObject *<VAR>object</VAR>, gchar *<VAR>name</VAR>)</I>
<DD><A NAME="IDX51"></A>
Similar to <CODE>gtk_signal_emit_stop</CODE> except that the signal is
referenced by <VAR>name</VAR> instead of by its integer identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_signal_connect</B> <I>(GtkObject *<VAR>object</VAR>, gchar *<VAR>name</VAR>, GtkSignalFunc <VAR>func</VAR>, gpointer <VAR>func_data</VAR>)</I>
<DD><A NAME="IDX52"></A>
Connects a signal handling function to a signal emitting
object. <VAR>func</VAR> is connected to the signal <VAR>name</VAR> emitted by
<VAR>object</VAR>. The arguments and returns type of <VAR>func</VAR> should match
the arguments and return type of the signal <VAR>name</VAR>. However,
<VAR>func</VAR> may take the extra argument of <VAR>func_data</VAR>. Due to the C
calling convention it is OK to ignore the extra argument. (It is OK to
ignore all the arguments in fact).

</P>
<P>
<CODE>gtk_signal_connect</CODE> returns an integer identifier for the
connection which can be used to refer to it in the future. Specifically
it is useful for removing the connection and/or blocking it from being
used.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_signal_connect_after</B> <I>(GtkObject *<VAR>object</VAR>, gchar *<VAR>name</VAR>, GtkSignalFunc <VAR>func</VAR>, gpointer <VAR>func_data</VAR>)</I>
<DD><A NAME="IDX53"></A>
Similar to <CODE>gtk_signal_connect</CODE> except the signal handler is
connected in the "after" slot. This allows a signal handler to be
guaranteed to run after other signal handlers connected to the same
signal on the same object and after the class function associated with
the signal.

</P>
<P>
Like <CODE>gtk_signal_connect</CODE>, <CODE>gtk_signal_connect_after</CODE> returns
an integer identifier which can be used to refer to the connection.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_signal_connect_object</B> <I>(GtkObject *<VAR>object</VAR>, gchar *<VAR>name</VAR>, GtkSignalFunc <VAR>func</VAR>, GtkObject *<VAR>slot_object</VAR>)</I>
<DD><A NAME="IDX54"></A>
Connects <VAR>func</VAR> to the signal <VAR>name</VAR> emitted by
<VAR>object</VAR>. Similar to <CODE>gtk_signal_connect</CODE> with the difference
that <VAR>slot_object</VAR> is passed as the first parameter to <VAR>func</VAR>
instead of the signal emitting object. This can be useful for connecting
a signal emitted by one object to a signal in another object. A common
usage is to connect the "destroy" signal of dialog to the "clicked"
signal emitted by a "close" button in the dialog. That is, the
"clicked" signal emitted by the button will caused the "destroy"
signal to be emitted for the dialog. This is also the "right" way to
handle closing of a dialog since the "destroy" signal will be sent if
the dialog is deleted using a window manager function and this enables
the two methods of closing the window to be handled by the same
mechanism. Returns an integer identifier which can be used to refer to
the connection.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_signal_connect_object_after</B> <I>(GtkObject *<VAR>object</VAR>, gchar *<VAR>name</VAR>, GtkSignalFunc <VAR>func</VAR>, GtkObject *<VAR>slot_object</VAR>)</I>
<DD><A NAME="IDX55"></A>
Similar to <CODE>gtk_signal_connect_object</CODE> except the signal handler is
connected in the "after" slot. This allows a signal handler to be
guaranteed to run after other signal handlers connected to the same
signal on the same object and after the class function associated with
the signal. Returns an integer identifier which can be used to refer to
the connection.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_signal_connect_interp</B> <I>(GtkObject *<VAR>object</VAR>, gchar *<VAR>name</VAR>, GtkCallbackMarshal <VAR>func</VAR>, gpointer <VAR>data</VAR>, GtkDestroyNotify <VAR>destroy_func</VAR>, gint <VAR>after</VAR>)</I>
<DD><A NAME="IDX56"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_signal_disconnect</B> <I>(GtkObject *<VAR>object</VAR>, gint <VAR>id</VAR>)</I>
<DD><A NAME="IDX57"></A>
Disconnects a signal handler from an object. The signal handler is
identified by the integer <VAR>id</VAR> which is returned by the
<CODE>gtk_signal_connect*</CODE> family of functions.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_signal_disconnect_by_data</B> <I>(GtkObject *<VAR>object</VAR>, gpointer <VAR>data</VAR>)</I>
<DD><A NAME="IDX58"></A>
Disconnects a signal handler from an object. The signal handler is
identified by the <VAR>data</VAR> argument specified as the <VAR>func_data</VAR>
argument to the <CODE>gtk_signal_connect*</CODE> family of functions. For the
<CODE>gtk_signal_connect_object*</CODE> functions, <VAR>data</VAR> refers to the
<VAR>slot_object</VAR>.

</P>
<P>
<STRONG>Note:</STRONG> This will remove all signal handlers connected to
<VAR>object</VAR> which were connected using <VAR>data</VAR> as their
<VAR>func_data</VAR> argument. Multiple signal handlers may be disconnected
with this call.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_signal_handler_block</B> <I>(GtkObject *<VAR>object</VAR>, gint <VAR>id</VAR>)</I>
<DD><A NAME="IDX59"></A>
Blocks calling of a signal handler during signal emission. The signal
handler is identified by the integer <VAR>id</VAR> which is returned by the
<CODE>gtk_signal_connect*</CODE> family of functions. If the signal is already
blocked no change is made.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_signal_handler_block_by_data</B> <I>(GtkObject *<VAR>object</VAR>, gint <VAR>data</VAR>)</I>
<DD><A NAME="IDX60"></A>
Blocks calling of a signal handler during signal emission. The signal
handler is identified by the <VAR>data</VAR> argument specified as the
<VAR>func_data</VAR> argument to the <CODE>gtk_signal_connect*</CODE> family of
functions. For the <CODE>gtk_signal_connect_object*</CODE> functions,
<VAR>data</VAR> refers to the <VAR>slot_object</VAR>. If the signal is already
blocked no change is made.

</P>
<P>
<STRONG>Note:</STRONG> This will block all signal handlers connected to
<VAR>object</VAR> which were connected using <VAR>data</VAR> as their
<VAR>func_data</VAR> argument. Multiple signal handlers may be blocked
with this call.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_signal_handler_unblock</B> <I>(GtkObject *<VAR>object</VAR>, gint <VAR>id</VAR>)</I>
<DD><A NAME="IDX61"></A>
Unblocks calling of a signal handler during signal emission. The signal
handler is identified by the integer <VAR>id</VAR> which is returned by the
<CODE>gtk_signal_connect*</CODE> family of functions. If the signal is already
unblocked no change is made.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_signal_handler_unblock_by_data</B> <I>(GtkObject *<VAR>object</VAR>, gint <VAR>data</VAR>)</I>
<DD><A NAME="IDX62"></A>
Unblocks calling of a signal handler during signal emission. The signal
handler is identified by the <VAR>data</VAR> argument specified as the
<VAR>func_data</VAR> argument to the <CODE>gtk_signal_connect*</CODE> family of
functions. For the <CODE>gtk_signal_connect_object*</CODE> functions,
<VAR>data</VAR> refers to the <VAR>slot_object</VAR>. If the signal is already
unblocked no change is made.

</P>
<P>
<STRONG>Note:</STRONG> This will unblock all signal handlers connected to
<VAR>object</VAR> which were connected using <VAR>data</VAR> as their
<VAR>func_data</VAR> argument. Multiple signal handlers may be unblocked
with this call.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_signal_handlers_destroy</B> <I>(GtkObject *<VAR>object</VAR>)</I>
<DD><A NAME="IDX63"></A>
Destroy all of the signal handlers connected to <VAR>object</VAR>. There
should normally never be reason to call this function as it is called
automatically when <VAR>object</VAR> is destroyed.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_signal_default_marshaller</B> <I>(GtkObject *<VAR>object</VAR>, GtkSignalFunc <VAR>func</VAR>, gpointer <VAR>func_data</VAR>, GtkSignalParam *<VAR>params</VAR>)</I>
<DD><A NAME="IDX64"></A>
<CODE>gtk_signal_new</CODE> requires a callback in order to actually call a
signal handler for a particular signal. The vast majority of signals are
of the particular form:

</P>

<PRE>
  (* std_signal) (gpointer std_arg);
</PRE>

<P>
<CODE>gtk_signal_default_marshaller</CODE> is a signal marshaller which
marshals arguments for a signal of that form.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_signal_set_funcs</B> <I>(GtkSignalMarshal <VAR>marshal_func</VAR>, GtkSignalDestroy <VAR>destroy_fun</VAR>)</I>
<DD><A NAME="IDX65"></A>
</DL>

</P>



<H1><A NAME="SEC15" HREF="gtk_toc.html#TOC15">Widget Overview</A></H1>
<P>
<A NAME="IDX66"></A>

</P>

<P>
Widgets are the general term used to describe user interface objects. A
widget defines a class interface that all user interface objects conform
to. This interface allows a uniform method for dealing with operations
common to all objects such as hiding and showing, size requisition and
allocation and events.

</P>
<P>
The common interface that widgets must adhere to is described by the
GtkWidget and GtkWidgetClass structure. For the purposes of using GTK
these structures can be considered read-only and, for the most part,
opaque.

</P>
<P>
All widget creation routines in GTK return pointers to GtkWidget
structures. In reality, all widget creation routines create structures
that can be viewed as equivalent to the GtkWidget structure, but often
have contain additional information. See section <A HREF="gtk.html#SEC414">Object internals</A>.

</P>
<P>
The widgets available for use are implemented in a hierarchy. Several
widgets exist solely as common bases for more specific widgets. For
example, it is not possible to create a ruler widget itself, but the
ruler widget provides a base and functionality common to the horizontal
and vertical rulers.

</P>
<P>
The available widgets (in alphabetical order):

</P>



<H2><A NAME="SEC16" HREF="gtk_toc.html#TOC16">The alignment widget</A></H2>



<H3><A NAME="SEC17" HREF="gtk_toc.html#TOC17">Description</A></H3>

<P>
The alignment widget is a container (see section <A HREF="gtk.html#SEC75">The container widget</A>) derived from
the bin widget (see section <A HREF="gtk.html#SEC31">The bin widget</A>). Its entire purpose is to give the
programmer flexibility in how the child it manages is positioned when a
window is resized.

</P>
<P>
Normally, a widget is allocated at least as much size as it
requests. (see section <A HREF="gtk.html#SEC75">The container widget</A> for a discussion of geometry
management). When a widget is allocated more size than it requests there
is a question of how the widget should expand. By convention, most GTK
widgets expand to fill their allocated space. Sometimes this behavior is
not desired. The alignment widget allows the programmer to specify how a
widget should expand and position itself to fill the area it is
allocated.

</P>


<H3><A NAME="SEC18" HREF="gtk_toc.html#TOC18">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>xscale</B>
<DD><A NAME="IDX67"></A>
<DT><U>User Option:</U> <B>yscale</B>
<DD><A NAME="IDX68"></A>
The <VAR>xscale</VAR> and <VAR>yscale</VAR> options specify how to scale the child
widget. If the scale value is 0.0, the child widget is allocated exactly
the size it requested in that dimension. If the scale value is 1.0, the
child widget is allocated all of the space in a dimension. A scale value
of 1.0 for both x and y is equivalent to not using an alignment widget.
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>xalign</B>
<DD><A NAME="IDX69"></A>
<DT><U>User Option:</U> <B>yalign</B>
<DD><A NAME="IDX70"></A>
The <VAR>xalign</VAR> and <VAR>yalign</VAR> options specify how to position the
child widget when it is not allocated all the space available to it
(because the <VAR>xscale</VAR> and/or <VAR>yscale</VAR> options are less than
1.0). If an alignment value is 0.0 the widget is positioned to the left
(or top) of its allocated space. An alignment value of 1.0 positions the
widget to the right (or bottom) of its allocated space. A common usage
is to specify <VAR>xalign</VAR> and <VAR>yalign</VAR> to be 0.5 which causes the
widget to be centered within its allocated area.
</DL>

</P>


<H3><A NAME="SEC19" HREF="gtk_toc.html#TOC19">Signals</A></H3>



<H3><A NAME="SEC20" HREF="gtk_toc.html#TOC20">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_alignment_get_type</B> <I>(void)</I>
<DD><A NAME="IDX71"></A>
Returns the <CODE>GtkAlignment</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_alignment_new</B> <I>(gfloat <VAR>xalign</VAR>, gfloat <VAR>yalign</VAR>, gfloat <VAR>xscale</VAR>, gfloat <VAR>yscale</VAR>)</I>
<DD><A NAME="IDX72"></A>
Create a new <CODE>GtkAlignment</CODE> object and initialize it with the
values <VAR>xalign</VAR>, <VAR>yalign</VAR>, <VAR>xscale</VAR> and <VAR>yscale</VAR>. The
new widget is returned as a pointer to a <CODE>GtkWidget</CODE>
object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_alignment_set</B> <I>(GtkAlignment *<VAR>alignment</VAR>, gfloat <VAR>xalign</VAR>, gfloat <VAR>yalign</VAR>, gfloat <VAR>xscale</VAR>, gfloat <VAR>yscale</VAR>)</I>
<DD><A NAME="IDX73"></A>
Set the <VAR>xalign</VAR>, <VAR>yalign</VAR>, <VAR>xscale</VAR> and <VAR>yscale</VAR> options
of an alignment widget. It is important to not set the fields of the
<CODE>GtkAlignment</CODE> structure directly (or, for that matter, any type
derived from <CODE>GtkObject</CODE>).
</DL>

</P>
<P>
@gtkstdmacros{Alignment, ALIGNMENT}

</P>


<H2><A NAME="SEC21" HREF="gtk_toc.html#TOC21">The arrow widget</A></H2>



<H3><A NAME="SEC22" HREF="gtk_toc.html#TOC22">Description</A></H3>

<P>
The arrow widget is derived from the misc widget (see section <A HREF="gtk.html#SEC218">The misc widget</A>) and
is intended for use where a directional arrow (in one of the four
cardinal directions) is desired. As such, it has very limited
functionality and basically only draws itself in a particular direction
and with a particular shadow type. The arrow widget will expand to fill
all the space it is allocated.

</P>


<H3><A NAME="SEC23" HREF="gtk_toc.html#TOC23">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>arrow_type</B>
<DD><A NAME="IDX74"></A>
The <VAR>arrow_type</VAR> option specifies which direction the arrow will
point. It can be one of <CODE>GTK_ARROW_UP</CODE>, <CODE>GTK_ARROW_DOWN</CODE>,
<CODE>GTK_ARROW_LEFT</CODE> or <CODE>GTK_ARROW_RIGHT</CODE>. This will set the arrow
pointing in the direction specified.
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>shadow_type</B>
<DD><A NAME="IDX75"></A>
The <VAR>shadow_type</VAR> option specifies how to draw the shadow for the
arrow. Currently, only the <CODE>GTK_SHADOW_IN</CODE> and
<CODE>GTK_SHADOW_OUT</CODE> shadow types are supported for drawing
arrows. Other shadow types will cause nothing to be drawn.
</DL>

</P>


<H3><A NAME="SEC24" HREF="gtk_toc.html#TOC24">Signals</A></H3>



<H3><A NAME="SEC25" HREF="gtk_toc.html#TOC25">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_arrow_get_type</B> <I>(void)</I>
<DD><A NAME="IDX76"></A>
Returns the <CODE>GtkArrow</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_arrow_new</B> <I>(GtkArrowType <VAR>arrow_type</VAR>, GtkShadowType <VAR>shadow_type</VAR>)</I>
<DD><A NAME="IDX77"></A>
Create a new <CODE>GtkArrow</CODE> object and initialize it with the values
<VAR>arrow_type</VAR> and <VAR>shadow_type</VAR>. The new widget is returned as a
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on
failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_arrow_set</B> <I>(GtkArrow *<VAR>arrow</VAR>, GtkArrowType <VAR>arrow_type</VAR>, GtkShadowType <VAR>shadow_type</VAR>)</I>
<DD><A NAME="IDX78"></A>
Set the <VAR>arrow_type</VAR> and <VAR>shadow_type</VAR> options of an arrow
widget. It is important to not set the fields of the <CODE>GtkArrow</CODE>
structure directly (or, for that matter, any type derived from
<CODE>GtkObject</CODE>).
</DL>

</P>
<P>
@gtkstdmacros{Arrow, ARROW}

</P>



<H2><A NAME="SEC26" HREF="gtk_toc.html#TOC26">The aspect frame widget</A></H2>



<H3><A NAME="SEC27" HREF="gtk_toc.html#TOC27">Description</A></H3>

<P>
Ensure that the child window has a specified aspect ratio or, if
obey_child, has the same aspect ratio as its requested size.  Derived
from see section <A HREF="gtk.html#SEC125">The frame widget</A>).

</P>


<H3><A NAME="SEC28" HREF="gtk_toc.html#TOC28">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>label</B>
<DD><A NAME="IDX79"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>xalign</B>
<DD><A NAME="IDX80"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>yalign</B>
<DD><A NAME="IDX81"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>ratio</B>
<DD><A NAME="IDX82"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>obey_child</B>
<DD><A NAME="IDX83"></A>
</DL>

</P>


<H3><A NAME="SEC29" HREF="gtk_toc.html#TOC29">Signals</A></H3>



<H3><A NAME="SEC30" HREF="gtk_toc.html#TOC30">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_aspect_frame_get_type</B> <I>(void)</I>
<DD><A NAME="IDX84"></A>
Returns the <CODE>GtkAspectFrame</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_aspect_frame_new</B> <I>(gchar *<VAR>label</VAR>, gfloat <VAR>xalign</VAR>, gfloat <VAR>yalign</VAR>, gfloat <VAR>ratio</VAR>, gint <VAR>obey_child</VAR>)</I>
<DD><A NAME="IDX85"></A>
Create a new <CODE>GtkAspectFrame</CODE> object and initialize it with the values 
<VAR>label</VAR>, <VAR>xalign</VAR>, <VAR>yalign</VAR>, <VAR>ratio</VAR> and <VAR>obey_child</VAR>.
The new widget is returned as a pointer to a <CODE>GtkWidget</CODE> object. 
<CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_aspect_frame_set</B> <I>(GtkAspectFrame *<VAR>aspect_frame</VAR>, gfloat <VAR>xalign</VAR>, gfloat <VAR>yalign</VAR>, gfloat <VAR>ratio</VAR>, gint <VAR>obey_child</VAR>)</I>
<DD><A NAME="IDX86"></A>
</DL>

</P>

<P>
@gtkstdmacros{AspectFrame, ASPECT_FRAME}

</P>


<H2><A NAME="SEC31" HREF="gtk_toc.html#TOC31">The bin widget</A></H2>



<H3><A NAME="SEC32" HREF="gtk_toc.html#TOC32">Description</A></H3>

<P>
The bin widget is a container (see section <A HREF="gtk.html#SEC75">The container widget</A>) derived from the
container widget. It is an abstract base class. That is, it is not
possible to create an actual bin widget. It exists only to provide a
base of functionality for other widgets. Specifically, the bin widget
provides a base for several other widgets that contain only a single
child. These widgets include alignments (see section <A HREF="gtk.html#SEC16">The alignment widget</A>), frames
(see section <A HREF="gtk.html#SEC125">The frame widget</A>), items (see section <A HREF="gtk.html#SEC180">The item widget</A>), viewports
(see section <A HREF="gtk.html#SEC342">The viewport widget</A>) and windows (see section <A HREF="gtk.html#SEC374">The window widget</A>)

</P>


<H3><A NAME="SEC33" HREF="gtk_toc.html#TOC33">Options</A></H3>



<H3><A NAME="SEC34" HREF="gtk_toc.html#TOC34">Signals</A></H3>



<H3><A NAME="SEC35" HREF="gtk_toc.html#TOC35">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_bin_get_type</B> <I>(void)</I>
<DD><A NAME="IDX87"></A>
Returns the <CODE>GtkBin</CODE> type identifier.
</DL>

</P>
<P>
@gtkstdmacros{Bin, BIN}

</P>



<H2><A NAME="SEC36" HREF="gtk_toc.html#TOC36">The box widget</A></H2>



<H3><A NAME="SEC37" HREF="gtk_toc.html#TOC37">Description</A></H3>

<P>
The box widget is a container (see section <A HREF="gtk.html#SEC75">The container widget</A>) derived from the
container widget. It is an abstract base class used by the horizontal
box (see section <A HREF="gtk.html#SEC135">The horizontal box widget</A>), the vertical box (see section <A HREF="gtk.html#SEC332">The vertical box widget</A>) and the 
(see section <A HREF="gtk.html#SEC41">The button box widget</A>) widgets to provide a base of common functionality.

</P>
<P>
A box provides an abstraction for organizing the position and size of
widgets. Widgets in a box are laid out horizontally or vertically. By
using a box widget appropriately, a programmer can control how widgets
are positioned and how they will be allocated space when a window gets
resized.

</P>
<P>
The key attribute of boxes is that they position their children in a
single row (horizontal boxes) or column (vertical boxes). In the case of
horizontal boxes, all children are stretched vertically. The vertical
size of the box is determined by the largest vertical requisition of all
of its children. Similarly, a vertical box stretches all of its children
horizontally. The horizontal size (of the vertical box) is determined by
the largest horizontal requisition of all of its children. An alignment
widget (see section <A HREF="gtk.html#SEC16">The alignment widget</A>) can be used to control child allocation
more precisely on a per child basis.

</P>
<P>
The second attribute of boxes is how they expand children. In the case
of a horizontal box, the main control is over how children are expanded
horizontally to fill the allocated area. (The rest of this discussion
will focus on horizontal boxes but it applies to vertical boxes as
well).

</P>
<P>
There are two flags which can be set controlling how a widget is
expanded horizontally in a horizontal box. These are the <CODE>expand</CODE>
and <CODE>fill</CODE>. There operation is fairly simple. If <CODE>expand</CODE> is
set, the child's potentially allocated area will expand to fill available
space. If <CODE>fill</CODE> is set, the child's actual allocated area will be
its potentially allocated area. There is a difference between
the potentially area (which is the area the box widget sets aside for
the child) and the actual allocated area (which is the area the box
widget actual allocates for the widget via
<CODE>gtk_widget_size_allocate</CODE>).

</P>
<P>
The allocation of space to children occurs as follows (for horizontal
boxes):

<OL>
<LI>

All children are allocated at least their requested size horizontally
and the maximum requested child size vertically.

<LI>

Any child with the <CODE>expand</CODE> flag set is allocated <CODE>extra_width
/ nexpand_children</CODE> extra pixels horizontally. If the <CODE>homogeneous</CODE>
flag was set, all children are considered to have the <CODE>expand</CODE> flag
set. That is, all children will be allocated the same area.The
horizontal box is a fair widget and, as such, divides up any extra
allocated space evenly among the "expand" children. (Those children
which have the <CODE>expand</CODE> flag set). The exception occurs when
<CODE>extra_width / nexpand_children</CODE> does not divide cleanly. The extra
space is given to the last widget.

<LI>

<CODE>spacing</CODE> number of pixels separate each child. Note: The
separation is between the potentially allocated area for each child and
not the actual allocated area. The <CODE>padding</CODE> value associated with
each child causes that many pixels to be left empty to each side of the
child.

<LI>

If a child has the <CODE>fill</CODE> flag set it is allocated its potentially
allocated area. If it does not, it is allocated its requested size
horizontally and centered within its potentially allocated area. Its
vertical allocation is still the maximum requested size of any child.

<LI>

Children placed at the start of the box are placed in order of addition
to the box from left to right in the boxes allocated area.. Children
placed at the end of the box are placed in order of addition from right
to left in the boxes allocated area.
</OL>

<P>
See section <A HREF="gtk.html#SEC135">The horizontal box widget</A>, and section <A HREF="gtk.html#SEC332">The vertical box widget</A>, for code examples of using horizontal
and vertical boxes.

</P>


<H3><A NAME="SEC38" HREF="gtk_toc.html#TOC38">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>expand</B>
<DD><A NAME="IDX88"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>fill</B>
<DD><A NAME="IDX89"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>padding</B>
<DD><A NAME="IDX90"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>expand</B>
<DD><A NAME="IDX91"></A>
</DL>

</P>



<H3><A NAME="SEC39" HREF="gtk_toc.html#TOC39">Signals</A></H3>



<H3><A NAME="SEC40" HREF="gtk_toc.html#TOC40">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_box_get_type</B> <I>(void)</I>
<DD><A NAME="IDX92"></A>
Returns the <CODE>GtkBox</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_box_pack_start</B> <I>(GtkBox *<VAR>box</VAR>, GtkWidget *<VAR>child</VAR>, gint <VAR>expand</VAR>, gint <VAR>fill</VAR>, gint <VAR>padding</VAR>)</I>
<DD><A NAME="IDX93"></A>
Add <VAR>child</VAR> to the front of <VAR>box</VAR>. The flags <VAR>expand</VAR> and
<VAR>fill</VAR> and the padding value of <VAR>padding</VAR> are associated with
<VAR>child</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_box_pack_end</B> <I>(GtkBox *<VAR>box</VAR>, GtkWidget *<VAR>child</VAR>, gint <VAR>expand</VAR>, gint <VAR>fill</VAR>, gint <VAR>padding</VAR>)</I>
<DD><A NAME="IDX94"></A>
Add <VAR>child</VAR> to the end of <VAR>box</VAR>. The flags <VAR>expand</VAR> and
<VAR>fill</VAR> and the padding value of <VAR>padding</VAR> are associated with
<VAR>child</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_box_pack_start_defaults</B> <I>(GtkBox *<VAR>box</VAR>, GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX95"></A>
A convenience function which is equivalent to the following:

</P>

<PRE>
  gtk_box_pack_start (<VAR>box</VAR>, <VAR>widget</VAR>, TRUE, TRUE, 0);
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> void <B>gtk_box_pack_end_defaults</B> <I>(GtkBox *<VAR>box</VAR>, GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX96"></A>
A convenience function which is equivalent to the following:

</P>

<PRE>
  gtk_box_pack_start (<VAR>box</VAR>, <VAR>widget</VAR>, TRUE, TRUE, 0);
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> void <B>gtk_box_set_homogeneous</B> <I>(GtkBox *<VAR>box</VAR>, gint <VAR>homogeneous</VAR>)</I>
<DD><A NAME="IDX97"></A>
Set the homogeneous setting of this box to <VAR>homogeneous</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_box_set_spacing</B> <I>(GtkBox *<VAR>box</VAR>, gint <VAR>spacing</VAR>)</I>
<DD><A NAME="IDX98"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_box_reorder_child</B> <I>(GtkBox *<VAR>box</VAR>, GtkWidget *<VAR>child</VAR>, guint <VAR>pos</VAR>)</I>
<DD><A NAME="IDX99"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_box_query_child_packing</B> <I>(GtkBox *<VAR>box</VAR>, GtkWidget *<VAR>child</VAR>, gint *<VAR>expand</VAR>, gint *<VAR>fill</VAR>, gint *<VAR>padding</VAR>, GtkPackType *<VAR>pack_type</VAR>)</I>
<DD><A NAME="IDX100"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_box_set_child_packing</B> <I>(GtkBox *<VAR>box</VAR>, GtkWidget *<VAR>child</VAR>, gint <VAR>expand</VAR>, gint <VAR>fill</VAR>, gint <VAR>padding</VAR>, GtkPackType *<VAR>pack_type</VAR>)</I>
<DD><A NAME="IDX101"></A>
</DL>

</P>
<P>
@gtkstdmacros{Box, BOX}

</P>



<H2><A NAME="SEC41" HREF="gtk_toc.html#TOC41">The button box widget</A></H2>



<H3><A NAME="SEC42" HREF="gtk_toc.html#TOC42">Description</A></H3>
<P>
The button box widget is a container (see section <A HREF="gtk.html#SEC75">The container widget</A>) derived from the
(see section <A HREF="gtk.html#SEC36">The box widget</A>) widget. It is an abstract base class used by the horizontal
button box (see section <A HREF="gtk.html#SEC140">The horizontal button box widget</A>) and the vertical button box 
(see section <A HREF="gtk.html#SEC337">The vertical button box widget</A>) widgets to provide a base of common functionality.

</P>
<P>
The button box, like the box widget, (see section <A HREF="gtk.html#SEC36">The box widget</A>) provides an abstraction
for organizing position and size of widgets. In the case of the button box
it is targeted at the button widget,(see section <A HREF="gtk.html#SEC46">The button widget</A>). Button widgets are
laid out in the box horizontally or vertically. By using a button box widget 
appropriately, a programmer can control how the button widgets are positioned
and how they will be allocated space when a window gets resized.
 


<H3><A NAME="SEC43" HREF="gtk_toc.html#TOC43">Options</A></H3>
<P>
<DL>
<DT><U>User Option:</U> <B>layout_style</B>
<DD><A NAME="IDX102"></A>

<UL>

<UL>
<LI>

<CODE>GTK_BUTTONBOX_SPREAD</CODE>
</UL>

<LI>

The layout style <CODE>GTK_BUTTONBOX_SPREAD</CODE> will spread the buttons out
evenly within the button box. When the parent window is resized they will
re-adjust to the new window dimensions. The <CODE>gtk_button_box_set_spacing</CODE>
function will set the minimum space that the buttons will leave between
themselves.


<UL>
<LI>

<CODE>GTK_BUTTONBOX_EDGE</CODE>
</UL>

<LI>


<UL>
<LI>

<CODE>GTK_BUTTONBOX_START</CODE>
</UL>

<LI>

The layout style <CODE>GTK_BUTTONBOX_START</CODE> will place the buttons at the
start of the button box, taking into account the spacing as set by the
<CODE>gtk_button_box_set_spacing</CODE> function. The buttons will not move
when the parent window is re-sized. 


<UL>
<LI>

<CODE>GTK_BUTTONBOX_END</CODE>
</UL>

<LI>

The layout style <CODE>GTK_BUTTONBOX_END</CODE> will place the buttons at the
end of the button box, taking into account the spacing as set by the
<CODE>gtk_button_box_set_spacing</CODE> function. Again like the
<CODE>GTK_BUTTONBOX_START</CODE> layout style the buttons will not move when
the parent window is re-sized.
</UL>

</DL>

<P>
<DL>
<DT><U>User Option:</U> <B>width</B>
<DD><A NAME="IDX103"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>height</B>
<DD><A NAME="IDX104"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>ipad_x</B>
<DD><A NAME="IDX105"></A>
<DT><U>User Option:</U> <B>ipad_y</B>
<DD><A NAME="IDX106"></A>
</DL>

</P>


<H3><A NAME="SEC44" HREF="gtk_toc.html#TOC44">Signals</A></H3>



<H3><A NAME="SEC45" HREF="gtk_toc.html#TOC45">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_button_box_get_type</B> <I>(void)</I>
<DD><A NAME="IDX107"></A>
Returns the <CODE>GtkButtonBox</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_button_box_set_child_size_default</B> <I>(gint <VAR>width</VAR>, gint<VAR>height</VAR>)</I>
<DD><A NAME="IDX108"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_button_box_set_child_ipadding_default</B> <I>(gint <VAR>ipad_x</VAR>, gint <VAR>ipad_y</VAR>)</I>
<DD><A NAME="IDX109"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_button_box_get_child_size_default</B> <I>(gint *<VAR>width</VAR>, gint *<VAR>height</VAR>)</I>
<DD><A NAME="IDX110"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_button_box_get_child_ipadding_default</B> <I>(gint *<VAR>ipad_x</VAR>, gint *<VAR>ipad_y</VAR>)</I>
<DD><A NAME="IDX111"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_button_box_set_child_size</B> <I>(GtkButtonBox *<VAR>widget</VAR>, gint <VAR>width</VAR>, gint <VAR>height</VAR>)</I>
<DD><A NAME="IDX112"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_button_box_set_child_ipadding</B> <I>(GtkButtonBox *<VAR>widget</VAR>, gint <VAR>ipad_x</VAR>, gint <VAR>ipad_y</VAR>)</I>
<DD><A NAME="IDX113"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_button_box_set_layout</B> <I>(GtkButtonBox *<VAR>widget</VAR>, gint <VAR>layout_style</VAR>)</I>
<DD><A NAME="IDX114"></A>
This will set the layout style of the buttons within this box. Currently it can
be set to one of <CODE>GTK_BUTTONBOX_SPREAD</CODE>, <CODE>GTK_BUTTONBOX_EDGE</CODE>, 
<CODE>GTK_BUTTONBOX_START</CODE> or <CODE>GTK_BUTTONBOX_END</CODE>.

</P>
<P>
The following example:

<PRE>
    gtk_button_box_set_layout (GTK_BUTTON_BOX (box), 
                               GTK_BUTTONBOX_SPREAD);
</PRE>

<P>
Will set the <VAR>box</VAR> argument to the <STRONG>SPREAD</STRONG> layout style described 
above.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_button_box_get_spacing</B> <I>(GtkButtonBox *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX115"></A>
Get the per widget value for spacing within the button box. This value is
the amount of space that will be between the individual buttons contained by
this box.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_button_box_get_child_size</B> <I>(GtkButtonBox *<VAR>widget</VAR>, gint *<VAR>width</VAR>, gint *<VAR>height</VAR>)</I>
<DD><A NAME="IDX116"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_button_box_get_child_ipadding</B> <I>(GtkButtonBox *<VAR>widget</VAR>, gint *<VAR>ipad_x</VAR>, gint *<VAR>ipad_y</VAR>)</I>
<DD><A NAME="IDX117"></A>
Get the per widget value for the padding inside the buttons. This value 
controls how large the buttons will be within the box.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_button_box_get_layout</B> <I>(GtkButtonBox *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX118"></A>
Get the <VAR>layout_style</VAR> for the <CODE>GtkButtonBox</CODE> object passed to this
function in the <VAR>widget</VAR> variable.

</P>

<PRE>
   layout = gtk_button_box_get_layout(GTK_BUTTON_BOX (box));
</PRE>

</DL>

<P>
@gtkstdmacros{ButtonBox, BUTTON_BOX}

</P>


<H2><A NAME="SEC46" HREF="gtk_toc.html#TOC46">The button widget</A></H2>



<H3><A NAME="SEC47" HREF="gtk_toc.html#TOC47">Description</A></H3>

<P>
A pressable button.  Contains a widget.  Changes its appearance
(hilites) when it gets the focus.  Changes its appearance (pressed) when
activated.  Derived from see section <A HREF="gtk.html#SEC75">The container widget</A>.

</P>


<H3><A NAME="SEC48" HREF="gtk_toc.html#TOC48">Signals</A></H3>

<P>
<DL>
<DT><U>Signal:</U> void <B>GtkButton::pressed</B> <I>(GtkButton *<VAR>button</VAR>)</I>
<DD><A NAME="IDX119"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkButton::released</B> <I>(GtkButton *<VAR>button</VAR>)</I>
<DD><A NAME="IDX120"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkButton::clicked</B> <I>(GtkButton *<VAR>button</VAR>)</I>
<DD><A NAME="IDX121"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkButton::enter</B> <I>(GtkButton *<VAR>button</VAR>)</I>
<DD><A NAME="IDX122"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkButton::leave</B> <I>(GtkButton *<VAR>button</VAR>)</I>
<DD><A NAME="IDX123"></A>
</DL>

</P>


<H3><A NAME="SEC49" HREF="gtk_toc.html#TOC49">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_button_get_type</B> <I>(void)</I>
<DD><A NAME="IDX124"></A>
Returns the <CODE>GtkButton</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_button_new</B> <I>(void)</I>
<DD><A NAME="IDX125"></A>
Create a new <CODE>GtkButton</CODE> object. The new widget is returned as a 
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_button_new_with_label</B> <I>(gchar *<VAR>label</VAR>)</I>
<DD><A NAME="IDX126"></A>
Create a new <CODE>GtkButton</CODE> object and set the text that is 
on the button to <VAR>label</VAR>. The new widget is returned as a 
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_button_pressed</B> <I>(GtkButton *<VAR>button</VAR>)</I>
<DD><A NAME="IDX127"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_button_released</B> <I>(GtkButton *<VAR>button</VAR>)</I>
<DD><A NAME="IDX128"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_button_clicked</B> <I>(GtkButton *<VAR>button</VAR>)</I>
<DD><A NAME="IDX129"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_button_enter</B> <I>(GtkButton *<VAR>button</VAR>)</I>
<DD><A NAME="IDX130"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_button_leave</B> <I>(GtkButton *<VAR>button</VAR>)</I>
<DD><A NAME="IDX131"></A>
</DL>

</P>
<P>
@gtkstdmacros{Button, BUTTON}

</P>



<H2><A NAME="SEC50" HREF="gtk_toc.html#TOC50">The check button widget</A></H2>



<H3><A NAME="SEC51" HREF="gtk_toc.html#TOC51">Description</A></H3>

<P>
Another form of toggle button (see section <A HREF="gtk.html#SEC307">The toggle button widget</A>) with an
indicator.  Contains a widget to the right of the indicator.  Changes
its appearance (hilites) when it gets the focus.

</P>


<H3><A NAME="SEC52" HREF="gtk_toc.html#TOC52">Options</A></H3>



<H3><A NAME="SEC53" HREF="gtk_toc.html#TOC53">Signals</A></H3>



<H3><A NAME="SEC54" HREF="gtk_toc.html#TOC54">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_check_button_get_type</B> <I>(void)</I>
<DD><A NAME="IDX132"></A>
Returns the <CODE>GtkCheckButton</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_check_button_new</B> <I>(void)</I>
<DD><A NAME="IDX133"></A>
Create a new <CODE>GtkCheckButton</CODE> object and initialize it with the 
default values in the library. The new widget is returned as a pointer
to a <CODE>GtkWidget</CODE> object. A <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_check_button_new_with_label</B> <I>(gchar *<VAR>label</VAR>)</I>
<DD><A NAME="IDX134"></A>
Create a new <CODE>GtkCheckButton</CODE> object and initialize it with the 
values <VAR>label</VAR>. The new widget is returned as a pointer to a
<CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on any failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkCheckButton* <B>GTK_CHECK_BUTTON</B> <I>(gpointer <VAR>obj</VAR>)</I>
<DD><A NAME="IDX135"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkCheckButtonClass* <B>GTK_CHECK_BUTTON_CLASS</B> <I>(gpointer <VAR>class</VAR>)</I>
<DD><A NAME="IDX136"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>GTK_IS_CHECK_BUTTON</B> <I>(gpointer <VAR>obj</VAR>)</I>
<DD><A NAME="IDX137"></A>
</DL>

</P>
<P>
@gtkstdmacros{CheckButton, CHECK_BUTTON}

</P>


<H2><A NAME="SEC55" HREF="gtk_toc.html#TOC55">The check menu item widget</A></H2>



<H3><A NAME="SEC56" HREF="gtk_toc.html#TOC56">Description</A></H3>

<P>
Derived from see section <A HREF="gtk.html#SEC208">The menu item widget</A>.  Very similar to a checkbutton
(see section <A HREF="gtk.html#SEC50">The check button widget</A>), except that it's a menu item.  Has a toggled
state which is displayed in a small rectangle to the left of the
contained widget.

</P>


<H3><A NAME="SEC57" HREF="gtk_toc.html#TOC57">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>label</B>
<DD><A NAME="IDX138"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>state</B>
<DD><A NAME="IDX139"></A>
</DL>

</P>


<H3><A NAME="SEC58" HREF="gtk_toc.html#TOC58">Signals</A></H3>

<P>
<DL>
<DT><U>Signal:</U> void <B>GtkCheckMenuItem::toggled</B> <I>(GtkCheckMenuItem *<VAR>check_menu_item</VAR>)</I>
<DD><A NAME="IDX140"></A>
</DL>

</P>


<H3><A NAME="SEC59" HREF="gtk_toc.html#TOC59">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_check_menu_item_get_type</B> <I>(void)</I>
<DD><A NAME="IDX141"></A>
Returns the <CODE>GtkCheckMenuItem</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_check_menu_item_new</B> <I>(void)</I>
<DD><A NAME="IDX142"></A>
Create a new <CODE>GtkCheckMenuItem</CODE> object. The new widget is returned as a
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_check_menu_item_new_with_label</B> <I>(gchar *<VAR>label</VAR>)</I>
<DD><A NAME="IDX143"></A>
Create a new <CODE>GtkCheckMenuItem</CODE> object and initialize it with the values
<VAR>label</VAR>. The new widget is returned as a pointer to a <CODE>GtkWidget</CODE>
object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_check_menu_item_set_state</B> <I>(GtkCheckMenuItem *<VAR>check_menu_item</VAR>, gint <VAR>state</VAR>)</I>
<DD><A NAME="IDX144"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_check_menu_item_toggled</B> <I>(GtkCheckMenuItem *<VAR>check_menu_item</VAR>)</I>
<DD><A NAME="IDX145"></A>
</DL>

</P>
<P>
@gtkstdmacros{CheckMenuItem, CHECK_MENU_ITEM}

</P>


<H2><A NAME="SEC60" HREF="gtk_toc.html#TOC60">The compound list widget</A></H2>



<H3><A NAME="SEC61" HREF="gtk_toc.html#TOC61">Description</A></H3>

<P>
A list of rows of columns, with a title row.  You can insert rows, and
delete rows.  The user can scroll around and select a row.  Derived from
see section <A HREF="gtk.html#SEC75">The container widget</A>.  Cells can be empty, have a text and/or pixmap, or
be a widget.

</P>


<H3><A NAME="SEC62" HREF="gtk_toc.html#TOC62">Options</A></H3>



<H3><A NAME="SEC63" HREF="gtk_toc.html#TOC63">Signals</A></H3>



<H3><A NAME="SEC64" HREF="gtk_toc.html#TOC64">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_clist_get_type</B> <I>(void)</I>
<DD><A NAME="IDX146"></A>
Returns the <CODE>GtkCList</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_clist_new</B> <I>(int <VAR>columns</VAR>)</I>
<DD><A NAME="IDX147"></A>
Create a new <CODE>GtkCList</CODE> initializing it with the value <VAR>columns</VAR>. 
The new widget is returned as a pointer to a <CODE>GtkWidget</CODE> object.
<CODE>NULL</CODE> is returned on failure.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_clist_new_with_titles</B> <I>(int <VAR>columns</VAR>, gchar *<VAR>titles[]</VAR>)</I>
<DD><A NAME="IDX148"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_set_border</B> <I>(GtkCList *<VAR>clist</VAR>, GtkShadowType <VAR>border</VAR>)</I>
<DD><A NAME="IDX149"></A>
Set the border style of the <VAR>clist</VAR> to the shadow type <VAR>border</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_set_selection_mode</B> <I>(GtkCList *<VAR>clist</VAR> GtkSelectionMode <VAR>mode</VAR>)</I>
<DD><A NAME="IDX150"></A>
Set the selection mode on the <VAR>clist</VAR> to the <VAR>mode</VAR> selection mode.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_set_policy</B> <I>(GtkCList *<VAR>clist</VAR>, GtkPolicyType <VAR>vscrollbar_policy</VAR>, GtkPolicyType <VAR>hscrollbar_policy</VAR>)</I>
<DD><A NAME="IDX151"></A>
Set the policy on the scrollbars on the <VAR>clist</VAR> to <VAR>vscrollbar_policy</VAR> and <VAR>hscrollbar_policy</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_freeze</B> <I>(GtkCList *<VAR>clist</VAR>)</I>
<DD><A NAME="IDX152"></A>
Stop all visual updates of the <VAR>clist</VAR>. Useful for when making a large
number of changes to a <CODE>GtkCList</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_thaw</B> <I>(GtkCList *<VAR>clist</VAR>)</I>
<DD><A NAME="IDX153"></A>
Allow all visual updates of the <VAR>clist</VAR> to resume. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_column_titles_show</B> <I>(GtkCList *<VAR>clist</VAR>)</I>
<DD><A NAME="IDX154"></A>
Show the column title buttons on the <VAR>clist</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_column_titles_hide</B> <I>(GtkCList *<VAR>clist</VAR>)</I>
<DD><A NAME="IDX155"></A>
Hide the column title buttons on the <VAR>clist</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_set_column_title</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>column</VAR>, gchar *<VAR>title</VAR>)</I>
<DD><A NAME="IDX156"></A>
Set the title in column <VAR>column</VAR> of the <VAR>clist</VAR> button to <VAR>title</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_set_column_widget</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>column</VAR>, GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX157"></A>
Set the <VAR>widget</VAR> instead of the title button for the column <VAR>column</VAR> 
in the <VAR>clist</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_set_column_justification</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>column</VAR>, GtkJustification <VAR>justification</VAR>)</I>
<DD><A NAME="IDX158"></A>
Set the <VAR>column</VAR>'s justification, in the <VAR>clist</VAR> to <VAR>justification</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_set_column_width</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>column</VAR>, gint <VAR>width</VAR>)</I>
<DD><A NAME="IDX159"></A>
Set the pixel width of column <VAR>column</VAR> in the <CODE>GtkCList</CODE> <VAR>clist</VAR>
to <VAR>width</VAR>. This function is a necessary step in creating a 
<CODE>GtkCList</CODE> because otherwise the column width is chosen from the width
of the column title, which is almost never correct.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_set_row_height</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>height</VAR>)</I>
<DD><A NAME="IDX160"></A>
Change the height of the rows in the <VAR>clist</VAR> to <VAR>height</VAR>. The default
is the height of the current font.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_moveto</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>row</VAR>, gint<VAR>column</VAR>, gfloat <VAR>row_align</VAR>, gfloat <VAR>col_align</VAR>)</I>
<DD><A NAME="IDX161"></A>
Scroll the viewing area of the <CODE>GtkClist</CODE> in <VAR>clist</VAR> to <VAR>column</VAR>
and <VAR>row</VAR>. The <VAR>row_align</VAR> and <VAR>col_align</VAR> are between zero and
one, representing the location the row should appear on screen. Setting 
<VAR>row_align</VAR> or the <VAR>col_align</VAR> to 0.0 will be the top or left of the
viewing area. Setting the <VAR>row_align</VAR> or <VAR>col_align</VAR> to 1.0 will
be the bottom or right of the viewing area. If the <VAR>row</VAR> or <VAR>column</VAR>
is -1 then there is no change.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_set_text</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>row</VAR>, gint <VAR>column</VAR>, gchar *<VAR>text</VAR>)</I>
<DD><A NAME="IDX162"></A>
Set a given cell's text, located by the <VAR>row</VAR> and <VAR>column</VAR>, to 
<VAR>text</VAR> replacing its current contents.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_set_pixmap</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>row</VAR>, gint <VAR>column</VAR>, GdkPixmap *<VAR>pixmap</VAR>, GdkBitmap *<VAR>mask</VAR>)</I>
<DD><A NAME="IDX163"></A>
Set a given cell's text, located by the <VAR>column</VAR> and <VAR>row</VAR> arguments,
to the pixmap described by the <VAR>pixmap</VAR> argument using the <VAR>mask</VAR> as 
its mask. The current contents of the cell will be replaced.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_setpixtext</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>row</VAR>, gint <VAR>column</VAR>, gchar *<VAR>text</VAR>, guint8 <VAR>spacing</VAR>, GdkPixmap *<VAR>pixmap</VAR>, GdkBitmap *<VAR>mask</VAR>)</I>
<DD><A NAME="IDX164"></A>
Set a given cell's text and pixmap, located by the <VAR>row</VAR> and <VAR>column</VAR>
arguments, to the text and pixmap described by the <VAR>pixmap</VAR> and <VAR>text</VAR>
arguments. The <VAR>mask</VAR> will be used for the pixmap mask and the 
<VAR>spacing</VAR> argument specifies the spacing between the two.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_set_foreground</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>row</VAR>, GdkColor *<VAR>color</VAR>)</I>
<DD><A NAME="IDX165"></A>
Set the foreground color of row <VAR>row</VAR> to <VAR>color</VAR> in the 
<CODE>GtkCList</CODE> <VAR>clist</VAR>. The <VAR>color</VAR> must
already be allocated.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_set_background</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>row</VAR>, GdkColor *<VAR>color</VAR>)</I>
<DD><A NAME="IDX166"></A>
Set the background color of row <VAR>row</VAR> to <VAR>color</VAR> in the 
<CODE>GtkCList</CODE> pointed to by <VAR>clist</VAR>. The color must be previously
allocated.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_set_shift</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>row</VAR>, gint <VAR>column</VAR>, gint <VAR>vertical</VAR>, gint <VAR>horizontal</VAR>)</I>
<DD><A NAME="IDX167"></A>
Set the horizontal and vertical shift for drawing the contents of the cell
located at <VAR>row</VAR> and <VAR>column</VAR>. The <VAR>vertical</VAR> and <VAR>horizontal</VAR>
arguments can be positive or negative. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_clist_append</B> <I>(GtkCList *<VAR>clist</VAR>, gchar *<VAR>text[]</VAR>)</I>
<DD><A NAME="IDX168"></A>
Append the given text, in the <VAR>text[]</VAR> argument,  to the <CODE>GtkCList</CODE> 
pointed to by the <VAR>clist</VAR>. The return value is the index of the row that
was just added.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_insert</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>row</VAR>, gchar *<VAR>text[]</VAR>)</I>
<DD><A NAME="IDX169"></A>
Insert a row into the <CODE>GtkCList</CODE> pointed to by <VAR>clist</VAR> at row 
<VAR>row</VAR> with the text in <VAR>text[]</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_remove</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>row</VAR>)</I>
<DD><A NAME="IDX170"></A>
Remove row index <VAR>row</VAR> from the <VAR>clist</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_set_row_data</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>row</VAR>, gpointer <VAR>data</VAR>)</I>
<DD><A NAME="IDX171"></A>
Will set an arbitrary data pointer, <VAR>data</VAR>, for row <VAR>row</VAR> in the
<CODE>GtkCList</CODE> pointed to by <VAR>clist</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gpointer <B>gtk_clist_get_row_data</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>row</VAR>)</I>
<DD><A NAME="IDX172"></A>
Return the data that was set for row <VAR>row</VAR> from the <CODE>GtkCList</CODE> pointed
to by <VAR>clist</VAR>. <CODE>NULL</CODE> is returned if no data was set.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_select_row</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>row</VAR>, gint <VAR>column</VAR>)</I>
<DD><A NAME="IDX173"></A>
Force selection of a row, located by <VAR>row</VAR> and <VAR>column</VAR>, in the 
<CODE>GtkCList</CODE> pointed to by <VAR>clist</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_unselect_row</B> <I>(GtkCList *<VAR>clist</VAR>, gint <VAR>row</VAR>, gint <VAR>column</VAR>)</I>
<DD><A NAME="IDX174"></A>
Force the unselection of a row, located by <VAR>row</VAR> and <VAR>column</VAR>, in the
<CODE>GtkCList</CODE> pointed to by <VAR>clist</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_clist_clear</B> <I>(GtkCList *<VAR>clist</VAR>)</I>
<DD><A NAME="IDX175"></A>
Clear the entire contents of the <CODE>GtkCList</CODE> pointed to by <VAR>clist</VAR>.
This is much faster then removing each item separately with 
<CODE>gtk_clist_remove</CODE>.
</DL>

</P>
<P>
@gtkstdmacros{CList, CLIST}

</P>


<H2><A NAME="SEC65" HREF="gtk_toc.html#TOC65">The color selector widget</A></H2>



<H3><A NAME="SEC66" HREF="gtk_toc.html#TOC66">Description</A></H3>

<P>
A widget that allows a user to pick a color in one of many ways.  They
can click on a color wheel or saturation bar.  They can change hue,
saturation, value, red, green, or blue with a slider, or by entering
values.  Also allows the user to set an alpha (opacity) value.  Derived
from see section <A HREF="gtk.html#SEC332">The vertical box widget</A>.

</P>


<H3><A NAME="SEC67" HREF="gtk_toc.html#TOC67">Options</A></H3>
<P>
<DL>
<DT><U>User Option:</U> <B>policy</B>
<DD><A NAME="IDX176"></A>

<UL>
<LI>

GTK_UPDATE_CONTINUOUS
<LI>

GTK_UPDATE_DISCONTINUOUS
<LI>

GTK_UPDATE_DELAYED
</UL>

</DL>

<P>
<DL>
<DT><U>User Option:</U> <B>color</B>
<DD><A NAME="IDX177"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>use_opacity</B>
<DD><A NAME="IDX178"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>title</B>
<DD><A NAME="IDX179"></A>
</DL>

</P>


<H3><A NAME="SEC68" HREF="gtk_toc.html#TOC68">Signals</A></H3>



<H3><A NAME="SEC69" HREF="gtk_toc.html#TOC69">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_color_selection_get_type</B> <I>(void)</I>
<DD><A NAME="IDX180"></A>
Returns the <CODE>GtkColorSelection</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_color_selection_new</B> <I>(void)</I>
<DD><A NAME="IDX181"></A>
Create a new <CODE>GtkColorSelection</CODE> object. The new object is returned as a
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_color_selection_set_update_policy</B> <I>(GtkColorSelection *<VAR>colorsel</VAR>, GtkUpdateType <VAR>policy</VAR>)</I>
<DD><A NAME="IDX182"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_color_selection_set_color</B> <I>(GtkColorSelection *<VAR>colorsel</VAR>, gdouble *<VAR>color</VAR>)</I>
<DD><A NAME="IDX183"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_color_selection_get_color</B> <I>(GtkColorSelection *<VAR>colorsel</VAR>, gdouble *<VAR>color</VAR>)</I>
<DD><A NAME="IDX184"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_color_selection_set_opacity</B> <I>(GtkColorSelection *<VAR>colorsel</VAR>, gint <VAR>use_opacity</VAR>)</I>
<DD><A NAME="IDX185"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_color_selection_dialog_get_type</B> <I>(void)</I>
<DD><A NAME="IDX186"></A>
Returns the <CODE>GtkColorSelection</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_color_selection_dialog_new</B> <I>(gchar *<VAR>title</VAR>)</I>
<DD><A NAME="IDX187"></A>
Create a new <CODE>GtkColorSelection</CODE> object initializing the title bar of 
the resulting dialog to <VAR>title</VAR>. The new widget is returned as a pointer
to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
@gtkstdmacros{ColorSelection, COLOR_SELECTION}

</P>


<H2><A NAME="SEC70" HREF="gtk_toc.html#TOC70">The combo widget</A></H2>



<H3><A NAME="SEC71" HREF="gtk_toc.html#TOC71">Description</A></H3>

<P>
Text input box which also lets you choose from pre-defined values from a
drop-down menu.  Derived from see section <A HREF="gtk.html#SEC135">The horizontal box widget</A>.

</P>


<H3><A NAME="SEC72" HREF="gtk_toc.html#TOC72">Options</A></H3>



<H3><A NAME="SEC73" HREF="gtk_toc.html#TOC73">Signals</A></H3>



<H3><A NAME="SEC74" HREF="gtk_toc.html#TOC74">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_combo_get_type</B> <I>(void)</I>
<DD><A NAME="IDX188"></A>
Returns the <CODE>GtkCombo</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_combo_new</B> <I>(void)</I>
<DD><A NAME="IDX189"></A>
Create a new <CODE>GtkCombo</CODE> object returning the new widget as a pointer to
a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_combo_set_value_in_list</B> <I>(GtkCombo *<VAR>combo</VAR>, gint <VAR>val</VAR>, gint <VAR>ok_if_empty</VAR>)</I>
<DD><A NAME="IDX190"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_combo_set_use_arrows</B> <I>(GtkCombo *<VAR>combo</VAR>, gint <VAR>val</VAR>)</I>
<DD><A NAME="IDX191"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_combo_set_use_arrows_always</B> <I>(GtkCombo *<VAR>combo</VAR>, gint <VAR>val</VAR>)</I>
<DD><A NAME="IDX192"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_combo_set_case_sensitive</B> <I>(GtkCombo *<VAR>combo</VAR>, gint <VAR>val</VAR>)</I>
<DD><A NAME="IDX193"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_combo_set_item_string</B> <I>(GtkCombo *<VAR>combo</VAR>, GtkItem *<VAR>item</VAR>, gchar *<VAR>item_value</VAR>)</I>
<DD><A NAME="IDX194"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_combo_set_popdown_strings</B> <I>(GtkCombo *<VAR>combo</VAR>, GList *<VAR>strings</VAR>)</I>
<DD><A NAME="IDX195"></A>
</DL>

</P>
<P>
@gtkstdmacros{Combo, COMBO}

</P>


<H2><A NAME="SEC75" HREF="gtk_toc.html#TOC75">The container widget</A></H2>



<H3><A NAME="SEC76" HREF="gtk_toc.html#TOC76">Description</A></H3>

<P>
A base class for objects that are built out of other widgets.  Many
widgets are containers.  For example, a button contains a widget.  That
widget might be a text label (usually is), or a pixmap, or even an hbox
which has a label and a pixmap.

</P>


<H3><A NAME="SEC77" HREF="gtk_toc.html#TOC77">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>border_width</B>
<DD><A NAME="IDX196"></A>
</DL>

</P>


<H3><A NAME="SEC78" HREF="gtk_toc.html#TOC78">Signals</A></H3>

<P>
<DL>
<DT><U>Signal:</U> void <B>GtkContainer::add</B> <I>(GtkContainer *<VAR>container</VAR>, GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX197"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkContainer::remove</B> <I>(GtkContainer *<VAR>container</VAR>, GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX198"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkContainer::need_resize</B> <I>(GtkContainer *<VAR>container</VAR>, GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX199"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkContainer::foreach</B> <I>(GtkContainer *<VAR>container</VAR>, GtkCallback <VAR>callback</VAR>, gpointer <VAR>callback_data</VAR>)</I>
<DD><A NAME="IDX200"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkContainer::focus</B> <I>(GtkContainer *<VAR>container</VAR>, GtkDirectionType <VAR>direction</VAR>)</I>
<DD><A NAME="IDX201"></A>
</DL>

</P>


<H3><A NAME="SEC79" HREF="gtk_toc.html#TOC79">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_container_get_type</B> <I>(void)</I>
<DD><A NAME="IDX202"></A>
Returns the <CODE>GtkContainer</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_container_border_width</B> <I>(GtkContainer *<VAR>container</VAR>, gint <VAR>border_width</VAR>)</I>
<DD><A NAME="IDX203"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_container_add</B> <I>(GtkContainer *<VAR>container</VAR>, GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX204"></A>
Add <VAR>widget</VAR> to the <VAR>container</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_container_remove</B> <I>(GtkContainer *<VAR>container</VAR>, GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX205"></A>
Remove <VAR>widget</VAR> from <VAR>container</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_container_disable_resize</B> <I>(GtkContainer *<VAR>container</VAR>)</I>
<DD><A NAME="IDX206"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_container_enable_resize</B> <I>(GtkContainer *<VAR>container</VAR>)</I>
<DD><A NAME="IDX207"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_container_block_resize</B> <I>(GtkContainer *<VAR>container</VAR>)</I>
<DD><A NAME="IDX208"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_container_unblock_resize</B> <I>(GtkContainer *<VAR>container</VAR>)</I>
<DD><A NAME="IDX209"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_container_need_resize</B> <I>(GtkContainer *<VAR>container</VAR>, GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX210"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_container_check_resize</B> <I>(GtkContainer *<VAR>container</VAR>, GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX211"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_container_foreach</B> <I>(GtkContainer *<VAR>container</VAR>, GtkCallback <VAR>callback</VAR>, gpointer <VAR>callback_data</VAR>)</I>
<DD><A NAME="IDX212"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_container_focus</B> <I>(GtkContainer *<VAR>container</VAR>, GtkDirectionType <VAR>direction</VAR>)</I>
<DD><A NAME="IDX213"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GList* <B>gtk_container_children</B> <I>(GtkContainer <VAR>container</VAR>)</I>
<DD><A NAME="IDX214"></A>
</DL>

</P>
<P>
@gtkstdmacros{Container, CONTAINER}

</P>


<H2><A NAME="SEC80" HREF="gtk_toc.html#TOC80">The multi-column tree widget</A></H2>



<H3><A NAME="SEC81" HREF="gtk_toc.html#TOC81">Description</A></H3>

<P>
The GtkCTree widget is a multi-columned list with a designated column, the 
<CODE>tree column</CODE>, to display hierarchically-organized data. Each node is
either a folder (a branch of the tree) or a leaf. Nodes can be
(recursively) expanded, collapsed, (un)selected, removed, moved, sorted etc. 

</P>
<P>
GtkCTree is a descendant of see section <A HREF="gtk.html#SEC60">The compound list widget</A>. Therefore, a cell in a column
other than the tree column can only contain a string, a pixmap, both or 
nothing. A node in the tree column can contain a string and up to two pixmaps
and masks, indicating the "folder openend" and "folder closed" status.

</P>
<P>
Compared to GtkCList, there is no concept of row numbers. Therefore, a number
of GtkCList methods had to be re-implemented taking <CODE>GList *node</CODE> 
arguments instead of <CODE>gint row</CODE>.

</P>


<H3><A NAME="SEC82" HREF="gtk_toc.html#TOC82">Options</A></H3>



<H3><A NAME="SEC83" HREF="gtk_toc.html#TOC83">Signals</A></H3>

<P>
<DL>
<DT><U>Signal:</U> void <B>GtkCTree::tree_expand</B> <I>(GtkCTree *<VAR>ctree</VAR>, GList *<VAR>node</VAR>)</I>
<DD><A NAME="IDX215"></A>
</DL>
<DL>
<DT><U>Signal:</U> void <B>GtkCTree::tree_collapse</B> <I>(GtkCTree *<VAR>ctree</VAR>, GList *<VAR>node</VAR>)</I>
<DD><A NAME="IDX216"></A>
</DL>
<DL>
<DT><U>Signal:</U> void <B>GtkCTree::tree_move</B> <I>(GtkCTree *<VAR>ctree</VAR>, GList *<VAR>node</VAR>, GList *<VAR>new_parent</VAR>, GList *<VAR>new_sibling</VAR>)</I>
<DD><A NAME="IDX217"></A>
</DL>
<DL>
<DT><U>Signal:</U> void <B>GtkCTree::tree_select_row</B> <I>(GtkCTree *<VAR>ctree</VAR>, GList *<VAR>row</VAR>, gint <VAR>column</VAR>)</I>
<DD><A NAME="IDX218"></A>
</DL>
<DL>
<DT><U>Signal:</U> void <B>GtkCTree::tree_unselect_row</B> <I>(GtkCTree *<VAR>ctree</VAR>, GList *<VAR>row</VAR>, gint <VAR>column</VAR>)</I>
<DD><A NAME="IDX219"></A>
</DL>

</P>


<H3><A NAME="SEC84" HREF="gtk_toc.html#TOC84">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> GtkType <B>gtk_ctree_get_type</B> <I>(void)</I>
<DD><A NAME="IDX220"></A>
Returns the <CODE>GtkCTree</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_ctree_new</B> <I>(gint <VAR>columns</VAR>, gint <VAR>tree_column</VAR>)</I>
<DD><A NAME="IDX221"></A>
Creates a new GtkCTree widget with the given number of columns and the given tree column.

</P>
<P>
On success, a pointer to the newly created widget is returned, and <CODE>NULL</CODE> otherwise.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_ctree_new_with_titles</B> <I>(gint <VAR>columns</VAR>, gint <VAR>tree_column</VAR>, gchar *<VAR>titles[]</VAR>)</I>
<DD><A NAME="IDX222"></A>
Creates a new GtkCTree widget with the given number of columns and the given tree column. The column titles are initialized to the strings of the array <VAR>titles</VAR>.

</P>
<P>
On success, a pointer to the newly created widget is returned, and <CODE>NULL</CODE> otherwise.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GList* <B>gtk_ctree_insert</B> <I>(GtkCTree *<VAR>ctree</VAR>, GList *<VAR>parent</VAR>, GList *<VAR>sibling</VAR>, gchar *<VAR>text[]</VAR>, guint8 <VAR>spacing</VAR>, GdkPixmap *<VAR>pixmap_closed</VAR>, GdkPixmap *<VAR>mask_closed</VAR>, GdkPixmap *<VAR>pixmap_opened</VAR>, GdkPixmap *<VAR>mask_opened</VAR>, gboolean <VAR>is_leaf</VAR>, gboolean <VAR>expanded</VAR>)</I>
<DD><A NAME="IDX223"></A>
Inserts a new node at the given position. If <VAR>parent</VAR> == NULL, the node is
inserted at root level. If <VAR>sibling</VAR> == NULL, the node is appended to the 
existing list of siblings. Otherwise, the node is inserted before <VAR>sibling</VAR>.
If not NULL, the two pixmaps/masks are used to indicate the opened/closed status
of the node. <VAR>spacing</VAR> is the number of pixels between pixmap and text.
If <VAR>is_leaf</VAR> == TRUE, the node cannot have any children.
The initial expanded/collapsed status is given by <VAR>expanded</VAR>.

</P>
<P>
On success, the pointer to the newly inserted node is returned, and NULL 
otherwise.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_ctree_remove</B> <I>(GtkCTree *<VAR>ctree</VAR>, GList *<VAR>node</VAR>)</I>
<DD><A NAME="IDX224"></A>
Removes the given node and all its children.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_ctree_clear</B> <I>(GtkCTree *<VAR>ctree</VAR>)</I>
<DD><A NAME="IDX225"></A>
Removes all nodes of <VAR>ctree</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_ctree_post_recursive</B> <I>(GtkCTree *<VAR>ctree</VAR>, GList *<VAR>node</VAR>, GtkCTreeFunc <VAR>func</VAR>, gpointer <VAR>data</VAR>)</I>
<DD><A NAME="IDX226"></A>
Apply <VAR>func</VAR> to <VAR>node</VAR> and all its children, traversing <VAR>ctree</VAR> in
post-order.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_ctree_pre_recursive</B> <I>(GtkCTree *<VAR>ctree</VAR>, GList *<VAR>node</VAR>, GtkCTreeFunc <VAR>func</VAR>, gpointer <VAR>data</VAR>)</I>
<DD><A NAME="IDX227"></A>
Apply <VAR>func</VAR> to <VAR>node</VAR> and all its children, traversing <VAR>ctree</VAR> in
pre-order.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gboolean <B>gtk_ctree_is_visible</B> <I>(GtkCTree *<VAR>ctree</VAR>, GList *<VAR>node</VAR>)</I>
<DD><A NAME="IDX228"></A>
Returns the visibility status of the given node. A node is said to be visible
if in the chain of parent nodes every node is expanded. Or : the node is 
currently being displayed (but not necessarily inside the viewing area).
</DL>

</P>

<P>
@gtkstdmacros{CTree, CTREE}

</P>


<H2><A NAME="SEC85" HREF="gtk_toc.html#TOC85">The curve widget</A></H2>



<H3><A NAME="SEC86" HREF="gtk_toc.html#TOC86">Description</A></H3>

<P>
Derived from see section <A HREF="gtk.html#SEC100">The drawing area widget</A>.

</P>


<H3><A NAME="SEC87" HREF="gtk_toc.html#TOC87">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>type</B>
<DD><A NAME="IDX229"></A>

<UL>
<LI>GTK_CURVE_TYPE_LINEAR

<LI>GTK_CURVE_TYPE_SPLINE

<LI>GTK_CURVE_TYPE_FREE

</UL>

</DL>



<H3><A NAME="SEC88" HREF="gtk_toc.html#TOC88">Signals</A></H3>



<H3><A NAME="SEC89" HREF="gtk_toc.html#TOC89">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_curve_get_type</B> <I>(void)</I>
<DD><A NAME="IDX230"></A>
Returns the <CODE>GtkCurve</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_curve_new</B> <I>(void)</I>
<DD><A NAME="IDX231"></A>
Create a new <CODE>GtkCurve</CODE> returning the new widget as a pointer to a 
<CODE>GtkWidget</CODE> object.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_curve_reset</B> <I>(GtkCurve *<VAR>curve</VAR>)</I>
<DD><A NAME="IDX232"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_curve_set_gamma</B> <I>(GtkCurve *<VAR>curve</VAR>, gfloat <VAR>gamma</VAR>)</I>
<DD><A NAME="IDX233"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_curve_set_range</B> <I>(GtkCurve *<VAR>curve</VAR>, gfloat <VAR>min_x</VAR>, gfloat <VAR>max_x</VAR>, gfloat <VAR>min_y</VAR>, gfloat <VAR>max_y</VAR>)</I>
<DD><A NAME="IDX234"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_curve_get_vector</B> <I>(GtkCurve *<VAR>curve</VAR>, int <VAR>veclen</VAR>, gfloat <VAR>vector[]</VAR>)</I>
<DD><A NAME="IDX235"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_curve_set_vector</B> <I>(GtkCurve *<VAR>curve</VAR>, int <VAR>veclen</VAR>, gfloat <VAR>vector[]</VAR>)</I>
<DD><A NAME="IDX236"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_curve_set_curve_type</B> <I>(GtkCurve *<VAR>curve</VAR>, GtkCurveType <VAR>type</VAR>)</I>
<DD><A NAME="IDX237"></A>
</DL>

</P>
<P>
@gtkstdmacros{Curve, CURVE}

</P>


<H2><A NAME="SEC90" HREF="gtk_toc.html#TOC90">The gamma curve widget</A></H2>



<H3><A NAME="SEC91" HREF="gtk_toc.html#TOC91">Description</A></H3>

<P>
Lets the user edit a gamma curve (a one-to-one mapping usually used to
adjust the intensity of an image to the physical characteristics of the
output device).  You can set the minimum and maximum values for input
and output.  You can set the initial vector as well.  You are guaranteed
that every input value will have a (not necessarily unique) output value
specified.  Derived from see section <A HREF="gtk.html#SEC332">The vertical box widget</A>.  Makes use of see section <A HREF="gtk.html#SEC85">The curve widget</A> to
draw the curve.

</P>


<H3><A NAME="SEC92" HREF="gtk_toc.html#TOC92">Options</A></H3>



<H3><A NAME="SEC93" HREF="gtk_toc.html#TOC93">Signals</A></H3>



<H3><A NAME="SEC94" HREF="gtk_toc.html#TOC94">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_gamma_curve_get_type</B> <I>(void)</I>
<DD><A NAME="IDX238"></A>
Returns the <CODE>GtkGamma</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_gamma_curve_new</B> <I>(void)</I>
<DD><A NAME="IDX239"></A>
Create a new <CODE>GtkGamma</CODE> returning the new widget as a pointer to a
<CODE>GtkWidget</CODE> object.
</DL>

</P>
<P>
@gtkstdmacros{GammaCurve, GAMMACURVE}

</P>


<H2><A NAME="SEC95" HREF="gtk_toc.html#TOC95">The dialog widget</A></H2>



<H3><A NAME="SEC96" HREF="gtk_toc.html#TOC96">Description</A></H3>
<P>
The dialog widget is a window (see section <A HREF="gtk.html#SEC374">The window widget</A>) that has a vertical box
(see section <A HREF="gtk.html#SEC332">The vertical box widget</A>), a horizontal box (see section <A HREF="gtk.html#SEC135">The horizontal box widget</A>), separated with a 
horizontal separator (see section <A HREF="gtk.html#SEC165">The horizontal separator widget</A>).

</P>


<H3><A NAME="SEC97" HREF="gtk_toc.html#TOC97">Options</A></H3>



<H3><A NAME="SEC98" HREF="gtk_toc.html#TOC98">Signals</A></H3>



<H3><A NAME="SEC99" HREF="gtk_toc.html#TOC99">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_dialog_get_type</B> <I>(void)</I>
<DD><A NAME="IDX240"></A>
Returns the <CODE>GtkDialog</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_dialog_new</B> <I>(void)</I>
<DD><A NAME="IDX241"></A>
Create a new <CODE>GtkDialog</CODE> object and return the new widget as a pointer
to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
@gtkstdmacros{Dialog, DIALOG}

</P>



<H2><A NAME="SEC100" HREF="gtk_toc.html#TOC100">The drawing area widget</A></H2>



<H3><A NAME="SEC101" HREF="gtk_toc.html#TOC101">Description</A></H3>

<P>
A base class for widgets that need a box to draw into.  So far, only
used by GtkCurve.

</P>


<H3><A NAME="SEC102" HREF="gtk_toc.html#TOC102">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>width</B>
<DD><A NAME="IDX242"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>height</B>
<DD><A NAME="IDX243"></A>
</DL>

</P>


<H3><A NAME="SEC103" HREF="gtk_toc.html#TOC103">Signals</A></H3>



<H3><A NAME="SEC104" HREF="gtk_toc.html#TOC104">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_drawing_area_get_type</B> <I>(void)</I>
<DD><A NAME="IDX244"></A>
Returns the <CODE>GtkDrawingArea</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_drawing_area_new</B> <I>(void)</I>
<DD><A NAME="IDX245"></A>
Create a new <CODE>GtkDrawingArea</CODE> object returning the new widget as a 
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_drawing_area_size</B> <I>(GtkDrawingArea *<VAR>darea</VAR>, gint <VAR>width</VAR>, gint <VAR>height</VAR>)</I>
<DD><A NAME="IDX246"></A>
Set the size of the <VAR>darea</VAR> widget, created previously, to <VAR>width</VAR> and <VAR>height</VAR>.
</DL>

</P>
<P>
@gtkstdmacros{DrawingArea, DRAWING_AREA}

</P>



<H2><A NAME="SEC105" HREF="gtk_toc.html#TOC105">The entry widget</A></H2>



<H3><A NAME="SEC106" HREF="gtk_toc.html#TOC106">Description</A></H3>

<P>
Enter text into this widget.  Derived from GtkEditable.  Can be
set so it isn't editable.

</P>


<H3><A NAME="SEC107" HREF="gtk_toc.html#TOC107">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>max</B>
<DD><A NAME="IDX247"></A>
With this option it is possible to set the <VAR>text_max_length</VAR> to the 
value specified in the <VAR>max</VAR> option. This value is a guint16 value.
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>text</B>
<DD><A NAME="IDX248"></A>
With this option it is possible to 'preload' the text that will be displayed 
in the <CODE>entry</CODE> widget to the string pointed to by <VAR>text</VAR>.
</DL>

</P>


<H3><A NAME="SEC108" HREF="gtk_toc.html#TOC108">Signals</A></H3>

<P>
<DL>
<DT><U>Signal:</U> void <B>GtkEntry::insert_text</B> <I>(GtkEntry *<VAR>entry</VAR>, gchar *<VAR>text</VAR>, gint <VAR>length</VAR>, gint *<VAR>position</VAR>)</I>
<DD><A NAME="IDX249"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkEntry::delete_text</B> <I>(GtkEntry *<VAR>entry</VAR>, gint <VAR>start_pos</VAR>, gint <VAR>end_pos</VAR>)</I>
<DD><A NAME="IDX250"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkEntry::changed</B> <I>(GtkEntry *<VAR>entry</VAR>)</I>
<DD><A NAME="IDX251"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkEntry::set_text</B> <I>(GtkEntry *<VAR>entry</VAR>)</I>
<DD><A NAME="IDX252"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkEntry::activate</B> <I>(GtkEntry *<VAR>entry</VAR>)</I>
<DD><A NAME="IDX253"></A>
</DL>

</P>


<H3><A NAME="SEC109" HREF="gtk_toc.html#TOC109">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_entry_get_type</B> <I>(void)</I>
<DD><A NAME="IDX254"></A>
Returns the <CODE>GtkEntry</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_entry_new</B> <I>(void)</I>
<DD><A NAME="IDX255"></A>
Create a new <CODE>GtkEntry</CODE> object. The new widget is returned 
as a pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on
failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_entry_new_with_max_length</B> <I>(guint16 <VAR>max</VAR>)</I>
<DD><A NAME="IDX256"></A>
Create a new <CODE>GtkEntry</CODE> object initializing it with the value <VAR>max</VAR>.
The new widget is returned as a pointer to a <CODE>GtkWidget</CODE> object. 
<CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_entry_set_text</B> <I>(GtkEntry *<VAR>entry</VAR>, gchar *<VAR>text</VAR>)</I>
<DD><A NAME="IDX257"></A>
Will set the text in the previously created <CODE>GtkEntry</CODE> object to 
<VAR>text</VAR>. It is important to not set the fields of the <CODE>GtkEntry</CODE>
structure directly (or, for that matter, any type derived from 
<CODE>GtkObject</CODE>).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_entry_append_text</B> <I>(GtkEntry *<VAR>entry</VAR>, gchar *<VAR>text</VAR>)</I>
<DD><A NAME="IDX258"></A>
Append the text that is in the <VAR>text</VAR> argument to the widgets text. It is
important to not set the fields of the <CODE>GtkEntry</CODE> structure directly.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_entry_prepend_text</B> <I>(GtkEntry *<VAR>entry</VAR>, gchar *<VAR>text</VAR>)</I>
<DD><A NAME="IDX259"></A>
Add the text in the <VAR>text</VAR> argument to the text in the <CODE>GtkEntry</CODE> 
widget. It is important to not set the fields of the <CODE>GtkEntry</CODE> structure
directly.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_entry_set_position</B> <I>(GtkEntry *<VAR>entry</VAR>, gint <VAR>position</VAR>)</I>
<DD><A NAME="IDX260"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_entry_set_visibility</B> <I>(GtkEntry *<VAR>entry</VAR>, gint <VAR>visible</VAR>)</I>
<DD><A NAME="IDX261"></A>
Will make the keystrokes entered into the <CODE>GtkEntry</CODE> object invisible
when <VAR>visible</VAR> is <CODE>TRUE</CODE>. Defaults to <CODE>FALSE</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gchar* <B>gtk_entry_get_text</B> <I>(GtkEntry *<VAR>entry</VAR>)</I>
<DD><A NAME="IDX262"></A>
Returns the text that is contained in the <CODE>GtkEntry</CODE> as a pointer to a 
<CODE>gchar</CODE> variable.
</DL>

</P>
<P>
@gtkstdmacros{Entry, ENTRY}

</P>


<H2><A NAME="SEC110" HREF="gtk_toc.html#TOC110">The event box widget</A></H2>



<H3><A NAME="SEC111" HREF="gtk_toc.html#TOC111">Description</A></H3>

<P>
Derived from see section <A HREF="gtk.html#SEC31">The bin widget</A>.  Used by see section <A HREF="gtk.html#SEC327">The tree item widget</A>.

</P>


<H3><A NAME="SEC112" HREF="gtk_toc.html#TOC112">Options</A></H3>



<H3><A NAME="SEC113" HREF="gtk_toc.html#TOC113">Signals</A></H3>



<H3><A NAME="SEC114" HREF="gtk_toc.html#TOC114">Functions</A></H3>
<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_event_box_get_type</B> <I>(void)</I>
<DD><A NAME="IDX263"></A>
Returns the <CODE>GtkEventBox</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_event_box_new</B> <I>(void)</I>
<DD><A NAME="IDX264"></A>
Create a new <CODE>GtkEventBox</CODE> returning the new widget as a pointer to
a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
@gtkstdmacros{GtkEventBox, EVENT_BOX}

</P>


<H2><A NAME="SEC115" HREF="gtk_toc.html#TOC115">The file selection dialog widget</A></H2>



<H3><A NAME="SEC116" HREF="gtk_toc.html#TOC116">Description</A></H3>



<H3><A NAME="SEC117" HREF="gtk_toc.html#TOC117">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>title</B>
<DD><A NAME="IDX265"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>filename</B>
<DD><A NAME="IDX266"></A>
</DL>

</P>


<H3><A NAME="SEC118" HREF="gtk_toc.html#TOC118">Signals</A></H3>



<H3><A NAME="SEC119" HREF="gtk_toc.html#TOC119">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_file_selection_get_type</B> <I>(void)</I>
<DD><A NAME="IDX267"></A>
Returns the <CODE>GtkFileSelection</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_file_selection_new</B> <I>(gchar *<VAR>title</VAR>)</I>
<DD><A NAME="IDX268"></A>
Create a new <CODE>GtkFileSelection</CODE> object and return the new widget as a
pointer to a <CODE>GtkWidget</CODE>. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_file_selection_set_filename</B> <I>(GtkFileSelection *<VAR>filesel</VAR>, gchar *<VAR>filename</VAR>)</I>
<DD><A NAME="IDX269"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gchar* <B>gtk_file_selection_get_filename</B> <I>(GtkFileSelection *<VAR>filesel</VAR>)</I>
<DD><A NAME="IDX270"></A>
</DL>

</P>
<P>
@gtkstdmacros{FileSelection, FILE_SELECTION}

</P>


<H2><A NAME="SEC120" HREF="gtk_toc.html#TOC120">The fixed widget</A></H2>



<H3><A NAME="SEC121" HREF="gtk_toc.html#TOC121">Description</A></H3>



<H3><A NAME="SEC122" HREF="gtk_toc.html#TOC122">Options</A></H3>



<H3><A NAME="SEC123" HREF="gtk_toc.html#TOC123">Signals</A></H3>



<H3><A NAME="SEC124" HREF="gtk_toc.html#TOC124">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_fixed_get_type</B> <I>(void)</I>
<DD><A NAME="IDX271"></A>
Returns the <CODE>GtkFixed</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_fixed_new</B> <I>(void)</I>
<DD><A NAME="IDX272"></A>
Create a new <CODE>GtkFixed</CODE> object returning the new widget as a pointer to 
a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_fixed_put_new</B> <I>(GtkFixed *<VAR>fixed</VAR>, GtkWidget *<VAR>widget</VAR>, gint16 <VAR>x</VAR>, gint16 <VAR>y</VAR>)</I>
<DD><A NAME="IDX273"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_fixed_move</B> <I>(GtkFixed *<VAR>fixed</VAR>, GtkWidget *<VAR>widget</VAR>, gint16 <VAR>x</VAR>, gint16 <VAR>y</VAR>)</I>
<DD><A NAME="IDX274"></A>
</DL>

</P>
<P>
@gtkstdmacros{Fixed, FIXED}

</P>


<H2><A NAME="SEC125" HREF="gtk_toc.html#TOC125">The frame widget</A></H2>



<H3><A NAME="SEC126" HREF="gtk_toc.html#TOC126">Options</A></H3>
<P>
<DL>
<DT><U>User Option:</U> <B>label</B>
<DD><A NAME="IDX275"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>xalign</B>
<DD><A NAME="IDX276"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>yalign</B>
<DD><A NAME="IDX277"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>type</B>
<DD><A NAME="IDX278"></A>
</DL>

</P>


<H3><A NAME="SEC127" HREF="gtk_toc.html#TOC127">Description</A></H3>



<H3><A NAME="SEC128" HREF="gtk_toc.html#TOC128">Signals</A></H3>



<H3><A NAME="SEC129" HREF="gtk_toc.html#TOC129">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_frame_get_type</B> <I>(void)</I>
<DD><A NAME="IDX279"></A>
Returns the <CODE>GtkFrame</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_frame_new</B> <I>(gchar *<VAR>label</VAR>)</I>
<DD><A NAME="IDX280"></A>
Create a new <CODE>GtkFrame</CODE> object initializing it with the value in 
<VAR>label</VAR>. The new widget is returned as a pointer to a <CODE>GtkWidget</CODE>
object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_frame_set_label</B> <I>(GtkFrame *<VAR>frame</VAR>, gchar *<VAR>label</VAR>)</I>
<DD><A NAME="IDX281"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_frame_set_label_align</B> <I>(GtkFrame *<VAR>frame</VAR>, gfloat <VAR>xalign</VAR>, gfloat <VAR>yalign</VAR>)</I>
<DD><A NAME="IDX282"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_frame_set_shadow_type</B> <I>(GtkFrame *<VAR>frame</VAR>, GtkShadowType <VAR>type</VAR>)</I>
<DD><A NAME="IDX283"></A>
</DL>

</P>
<P>
@gtkstdmacros{Frame, FRAME}

</P>


<H2><A NAME="SEC130" HREF="gtk_toc.html#TOC130">The gamma widget</A></H2>



<H3><A NAME="SEC131" HREF="gtk_toc.html#TOC131">Description</A></H3>



<H3><A NAME="SEC132" HREF="gtk_toc.html#TOC132">Options</A></H3>



<H3><A NAME="SEC133" HREF="gtk_toc.html#TOC133">Signals</A></H3>



<H3><A NAME="SEC134" HREF="gtk_toc.html#TOC134">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_gamma_curve_get_type</B> <I>(void)</I>
<DD><A NAME="IDX284"></A>
Returns the <CODE>GtkGamma</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_gamma_curve_new</B> <I>(void)</I>
<DD><A NAME="IDX285"></A>
Create a new <CODE>GtkGamma</CODE> object returning the new widget as a pointer 
to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
@gtkstdmacros{Gamma, GAMMA}

</P>


<H2><A NAME="SEC135" HREF="gtk_toc.html#TOC135">The horizontal box widget</A></H2>



<H3><A NAME="SEC136" HREF="gtk_toc.html#TOC136">Description</A></H3>



<H3><A NAME="SEC137" HREF="gtk_toc.html#TOC137">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>homogeneous</B>
<DD><A NAME="IDX286"></A>
This option controls whether each object in the box has the same size. In the
case of the <CODE>GtkHBox</CODE>, this effects the width. If this option is set then
the <VAR>expand</VAR> option to the <CODE>gtk_box_pack</CODE> (see section <A HREF="gtk.html#SEC36">The box widget</A>) routines
is always set to <CODE>TRUE</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>spacing</B>
<DD><A NAME="IDX287"></A>
This option controls the amount of space that is added between the objects
packed into this <CODE>GtkVBox</CODE> object.
</DL>

</P>


<H3><A NAME="SEC138" HREF="gtk_toc.html#TOC138">Signals</A></H3>



<H3><A NAME="SEC139" HREF="gtk_toc.html#TOC139">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_hbox_get_type</B> <I>(void)</I>
<DD><A NAME="IDX288"></A>
Returns the <CODE>GtkHBox</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_hbox_new</B> <I>(gint <VAR>homogeneous</VAR>, gint <VAR>spacing</VAR>)</I>
<DD><A NAME="IDX289"></A>
Create a new <CODE>GtkHBox</CODE> object initializing it with the values in 
<VAR>homogeneous</VAR> and <VAR>spacing</VAR>. The new widget is returned as a pointer 
to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
@gtkstdmacros{HBox, HBOX}

</P>


<H2><A NAME="SEC140" HREF="gtk_toc.html#TOC140">The horizontal button box widget</A></H2>



<H3><A NAME="SEC141" HREF="gtk_toc.html#TOC141">Description</A></H3>



<H3><A NAME="SEC142" HREF="gtk_toc.html#TOC142">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>spacing</B>
<DD><A NAME="IDX290"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>layout</B>
<DD><A NAME="IDX291"></A>
</DL>

</P>


<H3><A NAME="SEC143" HREF="gtk_toc.html#TOC143">Signals</A></H3>



<H3><A NAME="SEC144" HREF="gtk_toc.html#TOC144">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_hbutton_box_get_type</B> <I>(void)</I>
<DD><A NAME="IDX292"></A>
Returns the <CODE>GtkHButtonBox</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_hbutton_box_new</B> <I>(void)</I>
<DD><A NAME="IDX293"></A>
Create a new <CODE>GtkHButtonBox</CODE> object returning the new widget as a pointer
to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_hbutton_box_set_spacing_default</B> <I>(gint <VAR>spacing</VAR>)</I>
<DD><A NAME="IDX294"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_hbutton_box_set_layout_default</B> <I>(gint <VAR>layout</VAR>)</I>
<DD><A NAME="IDX295"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_hbutton_box_get_spacing_default</B> <I>(void)</I>
<DD><A NAME="IDX296"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_hbutton_box_get_layout_default</B> <I>(void)</I>
<DD><A NAME="IDX297"></A>
</DL>

</P>
<P>
@gtkstdmacros {HButtonBox, HBUTTON_BOX}

</P>


<H2><A NAME="SEC145" HREF="gtk_toc.html#TOC145">The horizontal paned widget</A></H2>



<H3><A NAME="SEC146" HREF="gtk_toc.html#TOC146">Description</A></H3>



<H3><A NAME="SEC147" HREF="gtk_toc.html#TOC147">Options</A></H3>



<H3><A NAME="SEC148" HREF="gtk_toc.html#TOC148">Signals</A></H3>



<H3><A NAME="SEC149" HREF="gtk_toc.html#TOC149">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> void <B>gtk_hpaned_get_type</B> <I>(void)</I>
<DD><A NAME="IDX298"></A>
Returns the <CODE>GtkHPaned</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_hpaned_new</B> <I>(void)</I>
<DD><A NAME="IDX299"></A>
Create a new <CODE>GtkHPaned</CODE> object returning the new widget as a pointer 
to a <CODE>GtkWidget</CODE> object.
</DL>

</P>
<P>
@gtkstdmacros{HPaned, HPANED}

</P>


<H2><A NAME="SEC150" HREF="gtk_toc.html#TOC150">The horizontal ruler widget</A></H2>



<H3><A NAME="SEC151" HREF="gtk_toc.html#TOC151">Description</A></H3>



<H3><A NAME="SEC152" HREF="gtk_toc.html#TOC152">Options</A></H3>



<H3><A NAME="SEC153" HREF="gtk_toc.html#TOC153">Signals</A></H3>



<H3><A NAME="SEC154" HREF="gtk_toc.html#TOC154">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_hruler_get_type</B> <I>(void)</I>
<DD><A NAME="IDX300"></A>
Returns the <CODE>GtkHRuler</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_hruler_new</B> <I>(void)</I>
<DD><A NAME="IDX301"></A>
Create a new <CODE>GtkHRuler</CODE> object returning the new widget as a pointer
to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
@gtkstdmacros{HRuler, HRULER}

</P>



<H2><A NAME="SEC155" HREF="gtk_toc.html#TOC155">The horizontal scale widget</A></H2>



<H3><A NAME="SEC156" HREF="gtk_toc.html#TOC156">Description</A></H3>



<H3><A NAME="SEC157" HREF="gtk_toc.html#TOC157">Options</A></H3>



<H3><A NAME="SEC158" HREF="gtk_toc.html#TOC158">Signals</A></H3>



<H3><A NAME="SEC159" HREF="gtk_toc.html#TOC159">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_hscale_get_type</B> <I>(void)</I>
<DD><A NAME="IDX302"></A>
Returns the <CODE>GtkHScale</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_hscale_new</B> <I>(GtkAdjustment *<VAR>adjustment</VAR>)</I>
<DD><A NAME="IDX303"></A>
Create a new <CODE>GtkHScale</CODE> object returning the new widget as a pointer
to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
@gtkstdmacros{HScale, HSCALE}

</P>



<H2><A NAME="SEC160" HREF="gtk_toc.html#TOC160">The horizontal scrollbar widget</A></H2>



<H3><A NAME="SEC161" HREF="gtk_toc.html#TOC161">Description</A></H3>



<H3><A NAME="SEC162" HREF="gtk_toc.html#TOC162">Options</A></H3>



<H3><A NAME="SEC163" HREF="gtk_toc.html#TOC163">Signals</A></H3>



<H3><A NAME="SEC164" HREF="gtk_toc.html#TOC164">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_hscrollbar_get_type</B> <I>(void)</I>
<DD><A NAME="IDX304"></A>
Returns the <CODE>GtkHScrollbar</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_hscrollbar_new</B> <I>(GtkAdjustment *<VAR>adjustment</VAR>)</I>
<DD><A NAME="IDX305"></A>
Create a new <CODE>GtkHScrollbar</CODE> object returning the new widget as a 
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
@gtkstdmacros{HScrollbar, HSCROLLBAR}

</P>



<H2><A NAME="SEC165" HREF="gtk_toc.html#TOC165">The horizontal separator widget</A></H2>



<H3><A NAME="SEC166" HREF="gtk_toc.html#TOC166">Description</A></H3>



<H3><A NAME="SEC167" HREF="gtk_toc.html#TOC167">Options</A></H3>



<H3><A NAME="SEC168" HREF="gtk_toc.html#TOC168">Signals</A></H3>



<H3><A NAME="SEC169" HREF="gtk_toc.html#TOC169">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_hseparator_get_type</B> <I>(void)</I>
<DD><A NAME="IDX306"></A>
Returns the <CODE>GtkHSeparator</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_hseparator_new</B> <I>(void)</I>
<DD><A NAME="IDX307"></A>
Create a new <CODE>GtkHSeparator</CODE> object returning the new widget as a pointer
to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
@gtkstdmacros{HSeparator, HSEPARATOR}

</P>



<H2><A NAME="SEC170" HREF="gtk_toc.html#TOC170">The image widget</A></H2>



<H3><A NAME="SEC171" HREF="gtk_toc.html#TOC171">Description</A></H3>



<H3><A NAME="SEC172" HREF="gtk_toc.html#TOC172">Options</A></H3>



<H3><A NAME="SEC173" HREF="gtk_toc.html#TOC173">Signals</A></H3>



<H3><A NAME="SEC174" HREF="gtk_toc.html#TOC174">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_image_get_type</B> <I>(void)</I>
<DD><A NAME="IDX308"></A>
Returns the <CODE>GtkImage</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_image_new</B> <I>(GdkImage *<VAR>val</VAR>, GdkBitmap *<VAR>mask</VAR>)</I>
<DD><A NAME="IDX309"></A>
Create a new <CODE>GtkImage</CODE> object initializing it with the values in 
<VAR>val</VAR> and <VAR>mask</VAR>. The new widget is returned as a pointer to a 
<CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_image_set</B> <I>(GtkImage *<VAR>image</VAR>, GdkImage *<VAR>val</VAR>, GdkBitmap *<VAR>mask</VAR>)</I>
<DD><A NAME="IDX310"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_image_get</B> <I>(GtkImage *<VAR>image</VAR>, GdkImage **<VAR>val</VAR>, GdkBitmap **<VAR>mask</VAR>)</I>
<DD><A NAME="IDX311"></A>
</DL>

</P>
<P>
@gtkstdmacros{Image, IMAGE}

</P>


<H2><A NAME="SEC175" HREF="gtk_toc.html#TOC175">The input dialog widget</A></H2>



<H3><A NAME="SEC176" HREF="gtk_toc.html#TOC176">Description</A></H3>



<H3><A NAME="SEC177" HREF="gtk_toc.html#TOC177">Options</A></H3>



<H3><A NAME="SEC178" HREF="gtk_toc.html#TOC178">Signals</A></H3>

<P>
<DL>
<DT><U>Signal:</U> void <B>GtkInputDialog::enable_device</B> <I>(GtkInputDialog *<VAR>inputd</VAR>, guint32 <VAR>devid</VAR>, gpointer *<VAR>data</VAR>)</I>
<DD><A NAME="IDX312"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkInputDialog::disable_device</B> <I>(GtkInputDialog *<VAR>inputd</VAR>, guint32 <VAR>devid</VAR>, gpointer *<VAR>data</VAR>)</I>
<DD><A NAME="IDX313"></A>
</DL>

</P>


<H3><A NAME="SEC179" HREF="gtk_toc.html#TOC179">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_input_dialog_get_type</B> <I>(void)</I>
<DD><A NAME="IDX314"></A>
Returns the <CODE>GtkInputDialog</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_input_dialog_new</B> <I>(void)</I>
<DD><A NAME="IDX315"></A>
Create a new <CODE>GtkInputDialog</CODE> object and return the new widget as a 
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>

<P>
@gtkstdmacros{InputDialog, INPUTDIALOG}

</P>


<H2><A NAME="SEC180" HREF="gtk_toc.html#TOC180">The item widget</A></H2>



<H3><A NAME="SEC181" HREF="gtk_toc.html#TOC181">Description</A></H3>



<H3><A NAME="SEC182" HREF="gtk_toc.html#TOC182">Signals</A></H3>

<P>
<DL>
<DT><U>Signal:</U> void <B>GtkItem::select</B> <I>(GtkItem *<VAR>item</VAR>)</I>
<DD><A NAME="IDX316"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkItem::deselect</B> <I>(GtkItem *<VAR>item</VAR>)</I>
<DD><A NAME="IDX317"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkItem::toggle</B> <I>(GtkItem *<VAR>toggle</VAR>)</I>
<DD><A NAME="IDX318"></A>
</DL>

</P>


<H3><A NAME="SEC183" HREF="gtk_toc.html#TOC183">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_item_get_type</B> <I>(void)</I>
<DD><A NAME="IDX319"></A>
Returns the <CODE>GtkItem</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_item_select</B> <I>(GtkItem *<VAR>item</VAR>)</I>
<DD><A NAME="IDX320"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_item_deselect</B> <I>(GtkItem *<VAR>item</VAR>)</I>
<DD><A NAME="IDX321"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_item_toggle</B> <I>(GtkItem *<VAR>item</VAR>)</I>
<DD><A NAME="IDX322"></A>
</DL>

</P>
<P>
@gtkstdmacros{Item, ITEM}

</P>



<H2><A NAME="SEC184" HREF="gtk_toc.html#TOC184">The label widget</A></H2>



<H3><A NAME="SEC185" HREF="gtk_toc.html#TOC185">Description</A></H3>



<H3><A NAME="SEC186" HREF="gtk_toc.html#TOC186">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>str</B>
<DD><A NAME="IDX323"></A>
</DL>

</P>


<H3><A NAME="SEC187" HREF="gtk_toc.html#TOC187">Signals</A></H3>



<H3><A NAME="SEC188" HREF="gtk_toc.html#TOC188">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_label_get_type</B> <I>(void)</I>
<DD><A NAME="IDX324"></A>
Returns the <CODE>GtkLabel</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_label_new</B> <I>(GtkLabel *<VAR>label</VAR>, gchar *<VAR>str</VAR>)</I>
<DD><A NAME="IDX325"></A>
Create a new <CODE>GtkLabel</CODE> object and initialize it with the 
text in <VAR>str</VAR>. The new widget is returned as a pointer to a 
<CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_label_set</B> <I>(GtkLabel *<VAR>label</VAR>, gchar *<VAR>str</VAR>)</I>
<DD><A NAME="IDX326"></A>
Set the <CODE>GtkLabel</CODE> label value to the value passed in the <VAR>str</VAR> 
argument.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_label_get</B> <I>(GtkLabel *<VAR>label</VAR>, gchar **<VAR>str</VAR>)</I>
<DD><A NAME="IDX327"></A>
Copies the current value in the <CODE>GtkLabel</CODE> label field to the variable
passed in the <VAR>str</VAR> argument.
</DL>

</P>
<P>
@gtkstdmacros{Label, LABEL}

</P>



<H2><A NAME="SEC189" HREF="gtk_toc.html#TOC189">The list widget</A></H2>



<H3><A NAME="SEC190" HREF="gtk_toc.html#TOC190">Description</A></H3>



<H3><A NAME="SEC191" HREF="gtk_toc.html#TOC191">Signals</A></H3>

<P>
<DL>
<DT><U>Signal:</U> void <B>GtkList::selection_changed</B> <I>(GtkList *<VAR>list</VAR>)</I>
<DD><A NAME="IDX328"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkList::select_child</B> <I>(GtkList *<VAR>list</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX329"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkList::unselect_child</B> <I>(GtkList *<VAR>list</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX330"></A>
</DL>

</P>


<H3><A NAME="SEC192" HREF="gtk_toc.html#TOC192">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_list_get_type</B> <I>(void)</I>
<DD><A NAME="IDX331"></A>
Returns the <CODE>GtkList</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_list_new</B> <I>(void)</I>
<DD><A NAME="IDX332"></A>
Create a new <CODE>GtkList</CODE> object and return the new widget as a pointer to
a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_list_insert_items</B> <I>(GtkList *<VAR>list</VAR>, GList *<VAR>items</VAR>, gint <VAR>position</VAR>)</I>
<DD><A NAME="IDX333"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_list_append_items</B> <I>(GtkList *<VAR>list</VAR>, GList *<VAR>items</VAR>)</I>
<DD><A NAME="IDX334"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_list_prepend_items</B> <I>(GtkList *<VAR>list</VAR>, GList *<VAR>items</VAR>)</I>
<DD><A NAME="IDX335"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_list_remove_items</B> <I>(GtkList *<VAR>list</VAR>, GList *<VAR>items</VAR>)</I>
<DD><A NAME="IDX336"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_list_clear_items</B> <I>(GtkList *<VAR>list</VAR>, gint <VAR>start</VAR>, gint <VAR>end</VAR>)</I>
<DD><A NAME="IDX337"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_list_select_item</B> <I>(GtkList *<VAR>list</VAR>, gint <VAR>item</VAR>)</I>
<DD><A NAME="IDX338"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_list_unselect_item</B> <I>(GtkList *<VAR>list</VAR>, gint <VAR>item</VAR>)</I>
<DD><A NAME="IDX339"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_list_select_child</B> <I>(GtkList *<VAR>list</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX340"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_list_unselect_child</B> <I>(GtkList *<VAR>list</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX341"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_list_child_position</B> <I>(GtkList *<VAR>list</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX342"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_list_set_selection_mode</B> <I>(GtkList *<VAR>list</VAR>, GtkSelectionMode <VAR>mode</VAR>)</I>
<DD><A NAME="IDX343"></A>
</DL>

</P>
<P>
@gtkstdmacros{List, LIST}

</P>



<H2><A NAME="SEC193" HREF="gtk_toc.html#TOC193">The list item widget</A></H2>



<H3><A NAME="SEC194" HREF="gtk_toc.html#TOC194">Description</A></H3>



<H3><A NAME="SEC195" HREF="gtk_toc.html#TOC195">Options</A></H3>



<H3><A NAME="SEC196" HREF="gtk_toc.html#TOC196">Signals</A></H3>



<H3><A NAME="SEC197" HREF="gtk_toc.html#TOC197">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_list_item_get_type</B> <I>(void)</I>
<DD><A NAME="IDX344"></A>
Returns the <CODE>GtkListItem</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_list_item_new</B> <I>(void)</I>
<DD><A NAME="IDX345"></A>
Create a new <CODE>GtkListItem</CODE> object and return the new widget as a 
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_list_item_new_with_label</B> <I>(gchar *<VAR>label</VAR>)</I>
<DD><A NAME="IDX346"></A>
Create a new <CODE>GtkListItem</CODE> object initializing with the value <VAR>label</VAR>.
The new widget is returned as a pointer to a <CODE>GtkWidget</CODE> object. 
<CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_list_item_select</B> <I>(GtkListItem *<VAR>list_item</VAR>)</I>
<DD><A NAME="IDX347"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_list_item_deselect</B> <I>(GtkListItem *<VAR>list_item</VAR>)</I>
<DD><A NAME="IDX348"></A>
</DL>

</P>
<P>
@gtkstdmacros{ListItem, LIST_ITEM}

</P>



<H2><A NAME="SEC198" HREF="gtk_toc.html#TOC198">The menu widget</A></H2>



<H3><A NAME="SEC199" HREF="gtk_toc.html#TOC199">Description</A></H3>



<H3><A NAME="SEC200" HREF="gtk_toc.html#TOC200">Options</A></H3>



<H3><A NAME="SEC201" HREF="gtk_toc.html#TOC201">Signals</A></H3>



<H3><A NAME="SEC202" HREF="gtk_toc.html#TOC202">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_menu_get_type</B> <I>(void)</I>
<DD><A NAME="IDX349"></A>
Returns the <CODE>GtkMenu</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_menu_new</B> <I>(void)</I>
<DD><A NAME="IDX350"></A>
Create a new <CODE>GtkMenu</CODE> object returning the new widget as a pointer to 
a <CODE>GtkWidget</CODE>. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_append</B> <I>(GtkMenu *<VAR>menu</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX351"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_prepend</B> <I>(GtkMenu *<VAR>menu</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX352"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_insert</B> <I>(GtkMenu *<VAR>menu</VAR>, GtkWidget *<VAR>child</VAR>, gint <VAR>position</VAR>)</I>
<DD><A NAME="IDX353"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_popup</B> <I>(GtkMenu *<VAR>menu</VAR>, GtkWidget *<VAR>parent_menu_shell</VAR>, GtkWidget *<VAR>parent_menu_item</VAR>, GtkMenuPositionFunc <VAR>func</VAR>, gpointer <VAR>data</VAR>, gint <VAR>button</VAR>)</I>
<DD><A NAME="IDX354"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_popdown</B> <I>(GtkMenu *<VAR>menu</VAR>)</I>
<DD><A NAME="IDX355"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_menu_get_active</B> <I>(GtkMenu *<VAR>menu</VAR>)</I>
<DD><A NAME="IDX356"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_set_active</B> <I>(GtkMenu *<VAR>menu</VAR>)</I>
<DD><A NAME="IDX357"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_set_accelerator_table</B> <I>(GtkMenu *<VAR>menu</VAR>, GtkAcceleratorTable *<VAR>table</VAR>)</I>
<DD><A NAME="IDX358"></A>
</DL>

</P>
<P>
@gtkstdmacros{Menu, MENU}

</P>



<H2><A NAME="SEC203" HREF="gtk_toc.html#TOC203">The menu bar widget</A></H2>



<H3><A NAME="SEC204" HREF="gtk_toc.html#TOC204">Description</A></H3>



<H3><A NAME="SEC205" HREF="gtk_toc.html#TOC205">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>position</B>
<DD><A NAME="IDX359"></A>
</DL>

</P>


<H3><A NAME="SEC206" HREF="gtk_toc.html#TOC206">Signals</A></H3>



<H3><A NAME="SEC207" HREF="gtk_toc.html#TOC207">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_menu_bar_get_type</B> <I>(void)</I>
<DD><A NAME="IDX360"></A>
Returns the <CODE>GtkMenuBar</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_menu_bar_new</B> <I>(void)</I>
<DD><A NAME="IDX361"></A>
Create a new <CODE>GtkMenuBar</CODE> object returning the new widget as a pointer
to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_bar_append</B> <I>(GtkMenuBar *<VAR>menu_bar</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX362"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_bar_prepend</B> <I>(GtkMenuBar *<VAR>menu_bar</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX363"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_bar_insert</B> <I>(GtkMenuBar *<VAR>menu_bar</VAR>, GtkWidget *<VAR>child</VAR>, gint <VAR>position</VAR>)</I>
<DD><A NAME="IDX364"></A>
</DL>

</P>
<P>
@gtkstdmacros{MenuBar, MENU_BAR}

</P>



<H2><A NAME="SEC208" HREF="gtk_toc.html#TOC208">The menu item widget</A></H2>



<H3><A NAME="SEC209" HREF="gtk_toc.html#TOC209">Description</A></H3>



<H3><A NAME="SEC210" HREF="gtk_toc.html#TOC210">Options</A></H3>



<H3><A NAME="SEC211" HREF="gtk_toc.html#TOC211">Signals</A></H3>

<P>
<DL>
<DT><U>Signal:</U> void <B>GtkMenuItem::activate</B> <I>(GtkMenuItem *<VAR>menu_item</VAR>)</I>
<DD><A NAME="IDX365"></A>
</DL>

</P>


<H3><A NAME="SEC212" HREF="gtk_toc.html#TOC212">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_menu_item_get_type</B> <I>(void)</I>
<DD><A NAME="IDX366"></A>
Returns the <CODE>GtkMenuItem</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_menu_item_new</B> <I>(void)</I>
<DD><A NAME="IDX367"></A>
Create a new <CODE>GtkMenuItem</CODE> object returning the new widget as a pointer 
to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_menu_item_new_with_label</B> <I>(gchar *<VAR>label</VAR>)</I>
<DD><A NAME="IDX368"></A>
Create a new <CODE>GtkMenuItem</CODE> object initializing it with the value in 
<VAR>label</VAR>. The new widget is returned as a pointer to a <CODE>GtkWidget</CODE>
object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_item_set_submenu</B> <I>(GtkMenuItem *<VAR>menu_item</VAR>, GtkWidget *<VAR>submenu</VAR>)</I>
<DD><A NAME="IDX369"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_item_set_placement</B> <I>(GtkMenuItem *<VAR>menu_item</VAR>, GtkSubmenuPlacement <VAR>placement</VAR>)</I>
<DD><A NAME="IDX370"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_item_accelerator_size</B> <I>(GtkMenuItem *<VAR>menu_item</VAR>)</I>
<DD><A NAME="IDX371"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_item_accelerator_text</B> <I>(GtkMenuItem *<VAR>menu_item</VAR>, gchar *<VAR>buffer</VAR>)</I>
<DD><A NAME="IDX372"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_item_configure</B> <I>(GtkMenuItem *<VAR>menu_item</VAR>, gint <VAR>show_toggle_indicator</VAR>, gint <VAR>show_submenu_indicator</VAR>)</I>
<DD><A NAME="IDX373"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_item_select</B> <I>(GtkMenuItem *<VAR>menu_item</VAR>)</I>
<DD><A NAME="IDX374"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_item_deselect</B> <I>(GtkMenuItem *<VAR>menu_item</VAR>)</I>
<DD><A NAME="IDX375"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_item_activate</B> <I>(GtkMenuItem *<VAR>menu_item</VAR>)</I>
<DD><A NAME="IDX376"></A>
</DL>

</P>
<P>
@gtkstdmacros{MenuItem, MENU_ITEM}

</P>



<H2><A NAME="SEC213" HREF="gtk_toc.html#TOC213">The menu shell widget</A></H2>



<H3><A NAME="SEC214" HREF="gtk_toc.html#TOC214">Description</A></H3>



<H3><A NAME="SEC215" HREF="gtk_toc.html#TOC215">Options</A></H3>



<H3><A NAME="SEC216" HREF="gtk_toc.html#TOC216">Signals</A></H3>

<P>
<DL>
<DT><U>Signal:</U> void <B>GtkMenuShell::deactivate</B> <I>(GtkMenuShell *<VAR>menu_shell</VAR>)</I>
<DD><A NAME="IDX377"></A>
</DL>

</P>


<H3><A NAME="SEC217" HREF="gtk_toc.html#TOC217">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_menu_shell_get_type</B> <I>(void)</I>
<DD><A NAME="IDX378"></A>
Returns the <CODE>GtkMenuShell</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_shell_append</B> <I>(GtkMenuShell *<VAR>menu_shell</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX379"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_shell_prepend</B> <I>(GtkMenuShell *<VAR>menu_shell</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX380"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_shell_insert</B> <I>(GtkMenuShell *<VAR>menu_shell</VAR>, GtkWidget *<VAR>child</VAR>, gint <VAR>position</VAR>)</I>
<DD><A NAME="IDX381"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_menu_shell_deactivate</B> <I>(GtkMenuShell *<VAR>menu_shell</VAR>)</I>
<DD><A NAME="IDX382"></A>
</DL>

</P>
<P>
@gtkstdmacros{MenuShell, MENU_SHELL}

</P>



<H2><A NAME="SEC218" HREF="gtk_toc.html#TOC218">The misc widget</A></H2>



<H3><A NAME="SEC219" HREF="gtk_toc.html#TOC219">Description</A></H3>



<H3><A NAME="SEC220" HREF="gtk_toc.html#TOC220">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>xalign</B>
<DD><A NAME="IDX383"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>yalign</B>
<DD><A NAME="IDX384"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>xpad</B>
<DD><A NAME="IDX385"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>ypad</B>
<DD><A NAME="IDX386"></A>
</DL>

</P>


<H3><A NAME="SEC221" HREF="gtk_toc.html#TOC221">Signals</A></H3>



<H3><A NAME="SEC222" HREF="gtk_toc.html#TOC222">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_misc_get_type</B> <I>(void)</I>
<DD><A NAME="IDX387"></A>
Returns the <CODE>GtkMisc</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_misc_set_alignment</B> <I>(GtkMisc *<VAR>misc</VAR>, gfloat <VAR>xalign</VAR>, gfloat <VAR>yalign</VAR>)</I>
<DD><A NAME="IDX388"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_misc_set_padding</B> <I>(GtkMisc *<VAR>misc</VAR>, gint <VAR>xpad</VAR>, gint <VAR>ypad</VAR>)</I>
<DD><A NAME="IDX389"></A>
</DL>

</P>
<P>
@gtkstdmacros{Misc, MISC}

</P>



<H2><A NAME="SEC223" HREF="gtk_toc.html#TOC223">The notebook widget</A></H2>



<H3><A NAME="SEC224" HREF="gtk_toc.html#TOC224">Description</A></H3>



<H3><A NAME="SEC225" HREF="gtk_toc.html#TOC225">Options</A></H3>



<H3><A NAME="SEC226" HREF="gtk_toc.html#TOC226">Signals</A></H3>



<H3><A NAME="SEC227" HREF="gtk_toc.html#TOC227">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_notebook_get_type</B> <I>(void)</I>
<DD><A NAME="IDX390"></A>
Returns the <CODE>GtkNotebook</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_notebook_new</B> <I>(void)</I>
<DD><A NAME="IDX391"></A>
Create a new <CODE>GtkNotebook</CODE> object returning the new widget as a pointer
to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on a failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_notebook_append_page</B> <I>(GtkNotebook *<VAR>notebook</VAR>, GtkWidget *<VAR>child</VAR>, GtkWidget *<VAR>tab_label</VAR>)</I>
<DD><A NAME="IDX392"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_notebook_prepend_page</B> <I>(GtkNotebook *<VAR>notebook</VAR>, GtkWidget *<VAR>child</VAR>, GtkWidget *<VAR>tab_label</VAR>)</I>
<DD><A NAME="IDX393"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_notebook_insert_page</B> <I>(GtkNotebook *<VAR>notebook</VAR>, GtkWidget *<VAR>child</VAR>, GtkWidget *<VAR>tab_label</VAR>, gint <VAR>position</VAR>)</I>
<DD><A NAME="IDX394"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_notebook_remove_page</B> <I>(GtkNotebook *<VAR>notebook</VAR>, gint <VAR>page_num</VAR>)</I>
<DD><A NAME="IDX395"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_notebook_set_page</B> <I>(GtkNotebook *<VAR>notebook</VAR>, gint <VAR>page_num</VAR>)</I>
<DD><A NAME="IDX396"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_notebook_next_page</B> <I>(GtkNotebook *<VAR>notebook</VAR>)</I>
<DD><A NAME="IDX397"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_notebook_prev_page</B> <I>(GtkNotebook *<VAR>notebook</VAR>)</I>
<DD><A NAME="IDX398"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_notebook_set_tab_pos</B> <I>(GtkNotebook *<VAR>notebook</VAR>, GtkPositionType <VAR>pos</VAR>)</I>
<DD><A NAME="IDX399"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_notebook_set_show_tabs</B> <I>(GtkNotebook *<VAR>notebook</VAR>, gint <VAR>show_tabs</VAR>)</I>
<DD><A NAME="IDX400"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_notebook_set_show_border</B> <I>(GtkNotebook *<VAR>notebook</VAR>, gint <VAR>show_border</VAR>)</I>
<DD><A NAME="IDX401"></A>
</DL>

</P>
<P>
@gtkstdmacros{Notebook, NOTEBOOK}

</P>



<H2><A NAME="SEC228" HREF="gtk_toc.html#TOC228">The option menu widget</A></H2>



<H3><A NAME="SEC229" HREF="gtk_toc.html#TOC229">Description</A></H3>



<H3><A NAME="SEC230" HREF="gtk_toc.html#TOC230">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>index</B>
<DD><A NAME="IDX402"></A>
</DL>

</P>


<H3><A NAME="SEC231" HREF="gtk_toc.html#TOC231">Signals</A></H3>



<H3><A NAME="SEC232" HREF="gtk_toc.html#TOC232">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_option_menu_get_type</B> <I>(void)</I>
<DD><A NAME="IDX403"></A>
Returns the <CODE>GtkOptionMenu</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_option_menu_new</B> <I>(void)</I>
<DD><A NAME="IDX404"></A>
Create a new <CODE>GtkOptionMenu</CODE> object returning the new widget as a 
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_option_menu_get_menu</B> <I>(GtkOptionMenu *<VAR>option_menu</VAR>)</I>
<DD><A NAME="IDX405"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_option_menu_set_menu</B> <I>(GtkOptionMenu *<VAR>option_menu</VAR>, GtkWidget *<VAR>menu</VAR>)</I>
<DD><A NAME="IDX406"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_option_menu_remove_menu</B> <I>(GtkOptionMenu *<VAR>option_menu</VAR>)</I>
<DD><A NAME="IDX407"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_option_menu_set_history</B> <I>(GtkOptionMenu *<VAR>option_menu</VAR>, gint <VAR>index</VAR>)</I>
<DD><A NAME="IDX408"></A>
</DL>

</P>
<P>
@gtkstdmacros{OptionMenu, OPTION_MENU}

</P>


<H2><A NAME="SEC233" HREF="gtk_toc.html#TOC233">The paned widget</A></H2>



<H3><A NAME="SEC234" HREF="gtk_toc.html#TOC234">Description</A></H3>



<H3><A NAME="SEC235" HREF="gtk_toc.html#TOC235">Options</A></H3>



<H3><A NAME="SEC236" HREF="gtk_toc.html#TOC236">Signals</A></H3>



<H3><A NAME="SEC237" HREF="gtk_toc.html#TOC237">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_paned_get_type</B> <I>(void)</I>
<DD><A NAME="IDX409"></A>
Returns the <CODE>GtkPaned</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_paned_add1</B> <I>(GtkPaned *<VAR>paned</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX410"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_paned_add2</B> <I>(GtkPaned *<VAR>paned</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX411"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_paned_handle_size</B> <I>(GtkPaned *<VAR>paned</VAR>, guint16 <VAR>size</VAR>)</I>
<DD><A NAME="IDX412"></A>
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> void <B>gtk_paned_gutter_size</B> <I>(GtkPaned *<VAR>paned</VAR>, guint16 <VAR>size</VAR>)</I>
<DD><A NAME="IDX413"></A>
</DL>

</P>
<P>
@gtkstdmacros{Paned, PANED}

</P>


<H2><A NAME="SEC238" HREF="gtk_toc.html#TOC238">The pixmap widget</A></H2>



<H3><A NAME="SEC239" HREF="gtk_toc.html#TOC239">Description</A></H3>



<H3><A NAME="SEC240" HREF="gtk_toc.html#TOC240">Options</A></H3>



<H3><A NAME="SEC241" HREF="gtk_toc.html#TOC241">Signals</A></H3>



<H3><A NAME="SEC242" HREF="gtk_toc.html#TOC242">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_pixmap_get_type</B> <I>(void)</I>
<DD><A NAME="IDX414"></A>
Returns the <CODE>GtkPixmap</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_pixmap_new</B> <I>(GdkPixmap *<VAR>normal</VAR>, GdkPixmap *<VAR>active</VAR>, GdkPixmap *<VAR>prelight</VAR>, GdkPixmap *<VAR>selected</VAR>, GdkPixmap *<VAR>insensitive</VAR>)</I>
<DD><A NAME="IDX415"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_pixmap_set</B> <I>(GtkPixmap *<VAR>pixmap</VAR>, GdkPixmap *<VAR>val</VAR>, GtkStateType <VAR>state</VAR>)</I>
<DD><A NAME="IDX416"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_pixmap_get</B> <I>(GtkPixmap *<VAR>pixmap</VAR>, GdkPixmap **<VAR>val</VAR>, GtkStateType <VAR>state</VAR>)</I>
<DD><A NAME="IDX417"></A>
</DL>

</P>
<P>
@gtkstdmacros{Pixmap, PIXMAP}

</P>



<H2><A NAME="SEC243" HREF="gtk_toc.html#TOC243">The preview widget</A></H2>



<H3><A NAME="SEC244" HREF="gtk_toc.html#TOC244">Description</A></H3>



<H3><A NAME="SEC245" HREF="gtk_toc.html#TOC245">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>type</B>
<DD><A NAME="IDX418"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>width</B>
<DD><A NAME="IDX419"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>height</B>
<DD><A NAME="IDX420"></A>
</DL>

</P>


<H3><A NAME="SEC246" HREF="gtk_toc.html#TOC246">Signals</A></H3>



<H3><A NAME="SEC247" HREF="gtk_toc.html#TOC247">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_preview_get_type</B> <I>(void)</I>
<DD><A NAME="IDX421"></A>
Returns the <CODE>GtkPreview</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_preview_uninit</B> <I>(void)</I>
<DD><A NAME="IDX422"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_preview_new</B> <I>(GtkPreviewType <VAR>type</VAR>)</I>
<DD><A NAME="IDX423"></A>
Create a new <CODE>GtkPreview</CODE> object initializing it with the values in 
<VAR>type</VAR>. The new widget is returned as a pointer to a <CODE>GtkWidget</CODE> 
object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_preview_size</B> <I>(GtkPreview *<VAR>preview</VAR>, gint <VAR>width</VAR>, gint <VAR>height</VAR>)</I>
<DD><A NAME="IDX424"></A>
Set the size of the <VAR>preview</VAR> object to <VAR>width</VAR> and <VAR>height</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_preview_put</B> <I>(GtkPreview *<VAR>preview</VAR>, GdkWindow *<VAR>window</VAR>, GdkGC *<VAR>gc</VAR>, gint <VAR>srcx</VAR>, gint <VAR>srcy</VAR>, gint <VAR>destx</VAR>, gint <VAR>desty</VAR>, gint <VAR>width</VAR>, gint <VAR>height</VAR>)</I>
<DD><A NAME="IDX425"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_preview_put_row</B> <I>(GtkPreview *<VAR>preview</VAR>, guchar *<VAR>src</VAR>, guchar *<VAR>dest</VAR>, gint <VAR>x</VAR>, gint <VAR>y</VAR>, gint <VAR>w</VAR>)</I>
<DD><A NAME="IDX426"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_preview_draw_row</B> <I>(GtkPreview *<VAR>preview</VAR>, guchar <VAR>data</VAR>, gint <VAR>x</VAR>, gint <VAR>y</VAR>, gint <VAR>w</VAR>)</I>
<DD><A NAME="IDX427"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_preview_set_expand</B> <I>(GtkPreview *<VAR>preview</VAR>, gint <VAR>expand</VAR>)</I>
<DD><A NAME="IDX428"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_preview_set_gamma</B> <I>(double <VAR>gamma</VAR>)</I>
<DD><A NAME="IDX429"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_preview_set_color_cube</B> <I>(guint <VAR>nred_shades</VAR>, guint <VAR>ngreen_shades</VAR>, guint <VAR>nblue_shades</VAR>, guint <VAR>ngray_shades</VAR>)</I>
<DD><A NAME="IDX430"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_preview_set_install_cmap</B> <I>(gint <VAR>install_cmap</VAR>)</I>
<DD><A NAME="IDX431"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_preview_set_reserved</B> <I>(gint <VAR>nreserved</VAR>)</I>
<DD><A NAME="IDX432"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GdkVisual* <B>gtk_preview_get_visual</B> <I>(void)</I>
<DD><A NAME="IDX433"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GdkColormap* <B>gtk_preview_get_cmap</B> <I>(void)</I>
<DD><A NAME="IDX434"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkPreviewInfo* <B>gtk_preview_get_info</B> <I>(void)</I>
<DD><A NAME="IDX435"></A>
</DL>

</P>
<P>
@gtkstdmacros{Preview, PREVIEW}

</P>



<H2><A NAME="SEC248" HREF="gtk_toc.html#TOC248">The progress bar widget</A></H2>



<H3><A NAME="SEC249" HREF="gtk_toc.html#TOC249">Description</A></H3>



<H3><A NAME="SEC250" HREF="gtk_toc.html#TOC250">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>percentage</B>
<DD><A NAME="IDX436"></A>
</DL>

</P>


<H3><A NAME="SEC251" HREF="gtk_toc.html#TOC251">Signals</A></H3>



<H3><A NAME="SEC252" HREF="gtk_toc.html#TOC252">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_progress_bar_get_type</B> <I>(void)</I>
<DD><A NAME="IDX437"></A>
Returns the <CODE>GtkProgressBar</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_progress_bar_new</B> <I>(void)</I>
<DD><A NAME="IDX438"></A>
Create a new <CODE>GtkProgressBar</CODE> object returning the new widget as a 
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_progress_bar_update</B> <I>(GtkProgressBar *<VAR>pbar</VAR>, gfloat <VAR>percentage</VAR>)</I>
<DD><A NAME="IDX439"></A>
Cause the <CODE>GtkProgressBar</CODE> to update its visual appearance to reflect the
<VAR>percentage</VAR>.
</DL>

</P>
<P>
@gtkstdmacros{ProgressBar, PROGRESS_BAR}

</P>



<H2><A NAME="SEC253" HREF="gtk_toc.html#TOC253">The radio button widget</A></H2>



<H3><A NAME="SEC254" HREF="gtk_toc.html#TOC254">Description</A></H3>



<H3><A NAME="SEC255" HREF="gtk_toc.html#TOC255">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>group</B>
<DD><A NAME="IDX440"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>label</B>
<DD><A NAME="IDX441"></A>
</DL>

</P>


<H3><A NAME="SEC256" HREF="gtk_toc.html#TOC256">Signals</A></H3>



<H3><A NAME="SEC257" HREF="gtk_toc.html#TOC257">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_radio_button_get_type</B> <I>(void)</I>
<DD><A NAME="IDX442"></A>
Returns the <CODE>GtkRadioButton</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_radio_button_new</B> <I>(GSList *<VAR>group</VAR>)</I>
<DD><A NAME="IDX443"></A>
Create a new <CODE>GtkRadioButton</CODE> object initializing it with the value
in the <VAR>group</VAR> argument. The new widget is returned as a pointer to a 
<CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_radio_button_new_with_label</B> <I>(GSList *<VAR>group</VAR>, gchar *<VAR>label</VAR>)</I>
<DD><A NAME="IDX444"></A>
Create a new <CODE>GtkRadioButton</CODE> object initializing it with the values in
the <VAR>group</VAR> and <VAR>label</VAR> arguments. The new widget is returned as a 
pointer to <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GSList* <B>gtk_radio_button_group</B> <I>(GtkRadioButton *<VAR>radio_button</VAR>)</I>
<DD><A NAME="IDX445"></A>
</DL>

</P>
<P>
@gtkstdmacros{RadioButton, RADIO_BUTTON}

</P>



<H2><A NAME="SEC258" HREF="gtk_toc.html#TOC258">The radio button widget</A></H2>



<H3><A NAME="SEC259" HREF="gtk_toc.html#TOC259">Description</A></H3>



<H3><A NAME="SEC260" HREF="gtk_toc.html#TOC260">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>group</B>
<DD><A NAME="IDX446"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>label</B>
<DD><A NAME="IDX447"></A>
</DL>

</P>


<H3><A NAME="SEC261" HREF="gtk_toc.html#TOC261">Signals</A></H3>



<H3><A NAME="SEC262" HREF="gtk_toc.html#TOC262">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_radio_menu_item_get_type</B> <I>(void)</I>
<DD><A NAME="IDX448"></A>
Returns the <CODE>GtkRadioMenuItem</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_radio_menu_item_new</B> <I>(GSList *<VAR>group</VAR>)</I>
<DD><A NAME="IDX449"></A>
Create a new <CODE>GtkRadioMenuItem</CODE> object and initialize it with the 
values in <VAR>group</VAR>. The new widget is returned as a pointer to a 
<CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_radio_menu_item_new_with_label</B> <I>(GSList *<VAR>group</VAR>, gchar *<VAR>label</VAR>)</I>
<DD><A NAME="IDX450"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GSList* <B>gtk_radio_menu_item_group</B> <I>(GtkRadioMenuItem *<VAR>radio_menu_item</VAR>)</I>
<DD><A NAME="IDX451"></A>
</DL>

</P>
<P>
@gtkstdmacros{RadioMenuItem, RADIO_MENU_ITEM}

</P>



<H2><A NAME="SEC263" HREF="gtk_toc.html#TOC263">The range widget</A></H2>



<H3><A NAME="SEC264" HREF="gtk_toc.html#TOC264">Description</A></H3>



<H3><A NAME="SEC265" HREF="gtk_toc.html#TOC265">Options</A></H3>



<H3><A NAME="SEC266" HREF="gtk_toc.html#TOC266">Signals</A></H3>



<H3><A NAME="SEC267" HREF="gtk_toc.html#TOC267">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_range_get_type</B> <I>(void)</I>
<DD><A NAME="IDX452"></A>
Returns the <CODE>GtkRange</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkAdjustment* <B>gtk_range_get_adjustment</B> <I>(GtkRange *<VAR>range</VAR>)</I>
<DD><A NAME="IDX453"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_range_set_update_policy</B> <I>(GtkRange *<VAR>range</VAR>, GtkUpdatePolicy <VAR>policy</VAR>)</I>
<DD><A NAME="IDX454"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_range_set_adjustment</B> <I>(GtkRange *<VAR>range</VAR>, GtkAdjustment *<VAR>adjustment</VAR>)</I>
<DD><A NAME="IDX455"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_range_draw_background</B> <I>(GtkRange *<VAR>range</VAR>)</I>
<DD><A NAME="IDX456"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_range_draw_trough</B> <I>(GtkRange *<VAR>range</VAR>)</I>
<DD><A NAME="IDX457"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_range_draw_slider</B> <I>(GtkRange *<VAR>range</VAR>)</I>
<DD><A NAME="IDX458"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_range_draw_step_forw</B> <I>(GtkRange *<VAR>range</VAR>)</I>
<DD><A NAME="IDX459"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_range_draw_step_back</B> <I>(GtkRange *<VAR>range</VAR>)</I>
<DD><A NAME="IDX460"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_range_slider_update</B> <I>(GtkRange *<VAR>range</VAR>)</I>
<DD><A NAME="IDX461"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_range_trough_click</B> <I>(GtkRange *<VAR>range</VAR>, gint <VAR>x</VAR>, gint <VAR>y</VAR>)</I>
<DD><A NAME="IDX462"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_range_default_hslider_update</B> <I>(GtkRange *<VAR>range</VAR>)</I>
<DD><A NAME="IDX463"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_range_default_vslider_update</B> <I>(GtkRange *<VAR>range</VAR>)</I>
<DD><A NAME="IDX464"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_range_default_htrough_click</B> <I>(GtkRange *<VAR>range</VAR>, gint <VAR>x</VAR>, gint <VAR>y</VAR>)</I>
<DD><A NAME="IDX465"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_range_default_vtrough_click</B> <I>(GtkRange *<VAR>range</VAR>, gint <VAR>x</VAR>, gint <VAR>y</VAR>)</I>
<DD><A NAME="IDX466"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_range_default_hmotion</B> <I>(GtkRange *<VAR>range</VAR>, gint <VAR>xdelta</VAR>, gint <VAR>ydelta</VAR>)</I>
<DD><A NAME="IDX467"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_range_default_vmotion</B> <I>(GtkRange *<VAR>range</VAR>, gint <VAR>xdelta</VAR>, gint <VAR>ydelta</VAR>)</I>
<DD><A NAME="IDX468"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gfloat <B>gtk_range_calc_value</B> <I>(GtkRange *<VAR>range</VAR>, gint <VAR>position</VAR>)</I>
<DD><A NAME="IDX469"></A>
</DL>

</P>
<P>
@gtkstdmacros{Range, RANGE}

</P>



<H2><A NAME="SEC268" HREF="gtk_toc.html#TOC268">The ruler widget</A></H2>



<H3><A NAME="SEC269" HREF="gtk_toc.html#TOC269">Description</A></H3>



<H3><A NAME="SEC270" HREF="gtk_toc.html#TOC270">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>metric</B>
<DD><A NAME="IDX470"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>lower</B>
<DD><A NAME="IDX471"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>upper</B>
<DD><A NAME="IDX472"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>position</B>
<DD><A NAME="IDX473"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>max_size</B>
<DD><A NAME="IDX474"></A>
</DL>

</P>


<H3><A NAME="SEC271" HREF="gtk_toc.html#TOC271">Signals</A></H3>



<H3><A NAME="SEC272" HREF="gtk_toc.html#TOC272">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_ruler_get_type</B> <I>(void)</I>
<DD><A NAME="IDX475"></A>
Returns the <CODE>GtkRuler</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_ruler_set_metric</B> <I>(GtkRuler *<VAR>ruler</VAR>, GtkMetricType <VAR>metric</VAR>)</I>
<DD><A NAME="IDX476"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_ruler_set_range</B> <I>(GtkRuler *<VAR>ruler</VAR>, gfloat <VAR>lower</VAR>, gfloat <VAR>upper</VAR>, gfloat <VAR>position</VAR>, gfloat <VAR>max_size</VAR>)</I>
<DD><A NAME="IDX477"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_ruler_draw_ticks</B> <I>(GtkRuler *<VAR>ruler</VAR>)</I>
<DD><A NAME="IDX478"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_ruler_draw_pos</B> <I>(GtkRuler *<VAR>ruler</VAR>)</I>
<DD><A NAME="IDX479"></A>
</DL>

</P>
<P>
@gtkstdmacros{Ruler, RULER}

</P>



<H2><A NAME="SEC273" HREF="gtk_toc.html#TOC273">The scale widget</A></H2>



<H3><A NAME="SEC274" HREF="gtk_toc.html#TOC274">Description</A></H3>



<H3><A NAME="SEC275" HREF="gtk_toc.html#TOC275">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>digits</B>
<DD><A NAME="IDX480"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>draw_value</B>
<DD><A NAME="IDX481"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>pos</B>
<DD><A NAME="IDX482"></A>
</DL>

</P>


<H3><A NAME="SEC276" HREF="gtk_toc.html#TOC276">Signals</A></H3>



<H3><A NAME="SEC277" HREF="gtk_toc.html#TOC277">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_scale_get_type</B> <I>(void)</I>
<DD><A NAME="IDX483"></A>
Returns the <CODE>GtkScale</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_scale_set_digits</B> <I>(GtkScale *<VAR>scale</VAR>, gint <VAR>digits</VAR>)</I>
<DD><A NAME="IDX484"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_scale_set_draw_value</B> <I>(GtkScale *<VAR>scale</VAR>, gint <VAR>draw_value</VAR>)</I>
<DD><A NAME="IDX485"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_scale_set_value_pos</B> <I>(GtkScale *<VAR>scale</VAR>, gint <VAR>pos</VAR>)</I>
<DD><A NAME="IDX486"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_scale_value_width</B> <I>(GtkScale *<VAR>scale</VAR>)</I>
<DD><A NAME="IDX487"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_scale_draw_value</B> <I>(GtkScale *<VAR>scale</VAR>)</I>
<DD><A NAME="IDX488"></A>
</DL>

</P>
<P>
@gtkstdmacros{Scale, SCALE}

</P>



<H2><A NAME="SEC278" HREF="gtk_toc.html#TOC278">The scrollbar widget</A></H2>



<H3><A NAME="SEC279" HREF="gtk_toc.html#TOC279">Description</A></H3>



<H3><A NAME="SEC280" HREF="gtk_toc.html#TOC280">Options</A></H3>



<H3><A NAME="SEC281" HREF="gtk_toc.html#TOC281">Signals</A></H3>



<H3><A NAME="SEC282" HREF="gtk_toc.html#TOC282">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_scrollbar_get_type</B> <I>(void)a</I>
<DD><A NAME="IDX489"></A>
Returns the <CODE>GtkScrollbar</CODE> type identifier.
</DL>

</P>
<P>
@gtkstdmacros{Scrollbar, SCROLLBAR}

</P>



<H2><A NAME="SEC283" HREF="gtk_toc.html#TOC283">The scrolled window widget</A></H2>



<H3><A NAME="SEC284" HREF="gtk_toc.html#TOC284">Description</A></H3>



<H3><A NAME="SEC285" HREF="gtk_toc.html#TOC285">Options</A></H3>



<H3><A NAME="SEC286" HREF="gtk_toc.html#TOC286">Signals</A></H3>



<H3><A NAME="SEC287" HREF="gtk_toc.html#TOC287">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_scrolled_window_get_type</B> <I>(void)</I>
<DD><A NAME="IDX490"></A>
Returns the <CODE>GtkScrolledWindow</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_scrolled_window_new</B> <I>(GtkAdjustment *<VAR>hadjustment</VAR>, GtkAdjustment *<VAR>vadjustment</VAR>)</I>
<DD><A NAME="IDX491"></A>
Create a new <CODE>GtkScrolledWindow</CODE> object initializing it with the values in
<VAR>adjustment</VAR> and <VAR>adjustment</VAR>. The new widget is returned as a 
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkAdjustment* <B>gtk_scrolled_window_get_hadjustment</B> <I>(GtkScrolledWindow *<VAR>scrolled_window</VAR>)</I>
<DD><A NAME="IDX492"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkAdjustment* <B>gtk_scrolled_window_get_vadjustment</B> <I>(GtkScrolledWindow *<VAR>scrolled_window</VAR>)</I>
<DD><A NAME="IDX493"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_scrolled_window_set_policy</B> <I>(GtkScrolledWindow *<VAR>scrolled_window</VAR>, GtkPolicyType <VAR>hscrollbar_policy</VAR>, GtkPolicyType <VAR>vscrollbar_policy</VAR>)</I>
<DD><A NAME="IDX494"></A>
</DL>

</P>
<P>
@gtkstdmacros{ScrolledWindow, SCROLLED_WINDOW}

</P>



<H2><A NAME="SEC288" HREF="gtk_toc.html#TOC288">The separator widget</A></H2>



<H3><A NAME="SEC289" HREF="gtk_toc.html#TOC289">Description</A></H3>



<H3><A NAME="SEC290" HREF="gtk_toc.html#TOC290">Options</A></H3>



<H3><A NAME="SEC291" HREF="gtk_toc.html#TOC291">Signals</A></H3>



<H3><A NAME="SEC292" HREF="gtk_toc.html#TOC292">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_separator_get_type</B> <I>(void)</I>
<DD><A NAME="IDX495"></A>
Returns the <CODE>GtkSeparator</CODE> type identifier.
</DL>

</P>
<P>
@gtkstdmacros{Separator, SEPARATOR}

</P>


<H2><A NAME="SEC293" HREF="gtk_toc.html#TOC293">The statusbar widget</A></H2>



<H3><A NAME="SEC294" HREF="gtk_toc.html#TOC294">Description</A></H3>



<H3><A NAME="SEC295" HREF="gtk_toc.html#TOC295">Options</A></H3>



<H3><A NAME="SEC296" HREF="gtk_toc.html#TOC296">Signals</A></H3>



<H3><A NAME="SEC297" HREF="gtk_toc.html#TOC297">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_statusbar_get_type</B> <I>(void)</I>
<DD><A NAME="IDX496"></A>
Returns the <CODE>GtkStatusbar</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_statusbar_new</B> <I>(void)</I>
<DD><A NAME="IDX497"></A>
Create a new <CODE>GtkStatusbar</CODE> object returning the new widget as a pointer
to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_statusbar_push</B> <I>(GtkStatusbar *<VAR>statusbar</VAR>, gchar *<VAR>text</VAR>)</I>
<DD><A NAME="IDX498"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_statusbar_pop</B> <I>(GtkStatusbar *<VAR>statusbar</VAR>, gint <VAR>context_id</VAR>)</I>
<DD><A NAME="IDX499"></A>
</DL>

</P>
<P>
@gtkstdmacros{Statusbar, STATUSBAR}

</P>


<H2><A NAME="SEC298" HREF="gtk_toc.html#TOC298">The table widget</A></H2>



<H3><A NAME="SEC299" HREF="gtk_toc.html#TOC299">Description</A></H3>



<H3><A NAME="SEC300" HREF="gtk_toc.html#TOC300">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>rows</B>
<DD><A NAME="IDX500"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>columns</B>
<DD><A NAME="IDX501"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>homogeneous</B>
<DD><A NAME="IDX502"></A>
This option controls whether all child widgets in the <CODE>GtkTable</CODE> will
be of the same size. The child widgets will be the size of the largest child.
</DL>

</P>


<H3><A NAME="SEC301" HREF="gtk_toc.html#TOC301">Signals</A></H3>



<H3><A NAME="SEC302" HREF="gtk_toc.html#TOC302">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_table_get_type</B> <I>(void)</I>
<DD><A NAME="IDX503"></A>
Returns the <CODE>GtkTable</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_table_new</B> <I>(gint <VAR>rows</VAR>, gint <VAR>columns</VAR>, gint <VAR>homogeneous</VAR>)</I>
<DD><A NAME="IDX504"></A>
Create a new <CODE>GtkTable</CODE> object initializing it with the values in 
<VAR>rows</VAR>, <VAR>columns</VAR> and <VAR>homogeneous</VAR>. The new widget is returned 
as a pointer to a <CODE>GtkWidget</CODE>. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_table_attach</B> <I>(GtkTable *<VAR>table</VAR>, GtkWidget *<VAR>child</VAR>, gint <VAR>left_attach</VAR>, gint <VAR>right_attach</VAR>, gint <VAR>top_attach</VAR>, gint <VAR>bottom_attach</VAR>, gint <VAR>xoptions</VAR>, gint <VAR>yoptions</VAR>, gint <VAR>xpadding</VAR>, gint <VAR>ypadding</VAR>)</I>
<DD><A NAME="IDX505"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_table_attach_defaults</B> <I>(GtkTable *<VAR>table</VAR>, GtkWidget *<VAR>widget</VAR>, gint <VAR>left_attach</VAR>, gint <VAR>right_attach</VAR>, gint <VAR>top_attach</VAR>, gint <VAR>bottom_attach</VAR>)</I>
<DD><A NAME="IDX506"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_table_set_row_spacing</B> <I>(GtkTable *<VAR>table</VAR>, gint <VAR>row</VAR>, gint <VAR>spacing</VAR>)</I>
<DD><A NAME="IDX507"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_table_set_col_spacing</B> <I>(GtkTable *<VAR>table</VAR>, gint <VAR>col</VAR>, gint <VAR>spacing</VAR>)</I>
<DD><A NAME="IDX508"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_table_set_row_spacings</B> <I>(GtkTable *<VAR>table</VAR>, gint <VAR>spacing</VAR>)</I>
<DD><A NAME="IDX509"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_table_set_col_spacings</B> <I>(GtkTable *<VAR>table</VAR>, gint <VAR>spacing</VAR>)</I>
<DD><A NAME="IDX510"></A>
</DL>

</P>
<P>
@gtkstdmacros{Table, TABLE}

</P>



<H2><A NAME="SEC303" HREF="gtk_toc.html#TOC303">The text widget</A></H2>



<H3><A NAME="SEC304" HREF="gtk_toc.html#TOC304">Description</A></H3>



<H3><A NAME="SEC305" HREF="gtk_toc.html#TOC305">Signals</A></H3>



<H3><A NAME="SEC306" HREF="gtk_toc.html#TOC306">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_text_get_type</B> <I>(void)</I>
<DD><A NAME="IDX511"></A>
Returns the <CODE>GtkText</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_text_new</B> <I>(GtkAdjustment *<VAR>hadj</VAR>, GtkAdjustment *<VAR>vadj</VAR>);</I>
<DD><A NAME="IDX512"></A>
Create a new <CODE>GtkText</CODE> object initializing it with the values in 
<VAR>hadj</VAR> and <VAR>vadj</VAR>. The new widget is returned as a pointer to a 
<CODE>GtkWidget</CODE>. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_text_set_editable</B> <I>(GtkText *<VAR>text</VAR>, gint <VAR>editable</VAR>)</I>
<DD><A NAME="IDX513"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_text_set_adjustments</B> <I>(GtkText *<VAR>text</VAR>, GtkAdjustment *<VAR>hadj</VAR>, GtkAdjustment *<VAR>vadj</VAR>)</I>
<DD><A NAME="IDX514"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_text_set_point</B> <I>(GtkText *<VAR>text</VAR>, guint <VAR>index</VAR>)</I>
<DD><A NAME="IDX515"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_text_get_point</B> <I>(GtkText *<VAR>text</VAR>)</I>
<DD><A NAME="IDX516"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_text_get_length</B> <I>(GtkText *<VAR>text</VAR>)</I>
<DD><A NAME="IDX517"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_text_freeze</B> <I>(GtkText *<VAR>text</VAR>)</I>
<DD><A NAME="IDX518"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_text_thaw</B> <I>(GtkText *<VAR>text</VAR>)</I>
<DD><A NAME="IDX519"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_text_insert</B> <I>(GtkText *<VAR>text</VAR>, GdkFont *<VAR>font</VAR>, GdkColor *<VAR>fore</VAR>, GdkColor *<VAR>back</VAR>, char *<VAR>chars</VAR>, gint <VAR>length</VAR>)</I>
<DD><A NAME="IDX520"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_text_forward_delete</B> <I>(GtkText *<VAR>text</VAR>, guint <VAR>nchars</VAR>)</I>
<DD><A NAME="IDX521"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_text_backward_delete</B> <I>(GtkText *<VAR>text</VAR>, guint <VAR>nchars</VAR>)</I>
<DD><A NAME="IDX522"></A>
</DL>

</P>

<P>
@gtkstdmacros{Text, TEXT}

</P>



<H2><A NAME="SEC307" HREF="gtk_toc.html#TOC307">The toggle button widget</A></H2>



<H3><A NAME="SEC308" HREF="gtk_toc.html#TOC308">Description</A></H3>

<P>
Another form of button (see section <A HREF="gtk.html#SEC46">The button widget</A>) with two states: on and off.
The appearance is that of a button which stays pressed on the first
click, and is released on the second click.

</P>


<H3><A NAME="SEC309" HREF="gtk_toc.html#TOC309">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>state</B>
<DD><A NAME="IDX523"></A>
</DL>

</P>


<H3><A NAME="SEC310" HREF="gtk_toc.html#TOC310">Signals</A></H3>

<P>
<DL>
<DT><U>Signal:</U> void <B>GtkToggleButton::toggled</B> <I>(GtkToggleButton *<VAR>toggle_button</VAR>)</I>
<DD><A NAME="IDX524"></A>
</DL>

</P>


<H3><A NAME="SEC311" HREF="gtk_toc.html#TOC311">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_toggle_button_get_type</B> <I>(void)</I>
<DD><A NAME="IDX525"></A>
Returns the <CODE>GtkToggleButton</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_toggle_button_new</B> <I>(void)</I>
<DD><A NAME="IDX526"></A>
Create a new <CODE>GtkToggleButton</CODE> object returning the new widget as a 
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_toggle_button_new_with_label</B> <I>(gchar *<VAR>label</VAR>)</I>
<DD><A NAME="IDX527"></A>
Create a new <CODE>GtkToggleButton</CODE> object initializing it with the values in
<VAR>label</VAR>. The new widget is returned as a pointer to a <CODE>GtkWidget</CODE> 
object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_toggle_button_set_mode</B> <I>(GtkToggleButton *<VAR>toggle_button</VAR>, gint <VAR>draw_indicator</VAR>)</I>
<DD><A NAME="IDX528"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_toggle_button_set_state</B> <I>(GtkToggleButton *<VAR>toggle_button</VAR>, gint <VAR>state</VAR>)</I>
<DD><A NAME="IDX529"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_toggle_button_toggled</B> <I>(GtkToggleButton *<VAR>toggle_button</VAR>)</I>
<DD><A NAME="IDX530"></A>
</DL>

</P>
<P>
@gtkstdmacros{ToggleButton, TOGGLE_BUTTON}

</P>



<H2><A NAME="SEC312" HREF="gtk_toc.html#TOC312">The tool bar widget</A></H2>



<H3><A NAME="SEC313" HREF="gtk_toc.html#TOC313">Description</A></H3>



<H3><A NAME="SEC314" HREF="gtk_toc.html#TOC314">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>orientation</B>
<DD><A NAME="IDX531"></A>

<UL>
<LI>GTK_ORIENTATION_HORIZONTAL

<LI>GTK_ORIENTATION_VERTICAL

</UL>

</DL>

<P>
<DL>
<DT><U>User Option:</U> <B>style</B>
<DD><A NAME="IDX532"></A>

<UL>
<LI>GTK_TOOLBAR_ICONS

<LI>GTK_TOOLBAR_TEXT

<LI>GTK_TOOLBAR_BOTH

</UL>

</DL>

<P>
<DL>
<DT><U>User Option:</U> <B>space_size</B>
<DD><A NAME="IDX533"></A>
</DL>

</P>


<H3><A NAME="SEC315" HREF="gtk_toc.html#TOC315">Signals</A></H3>



<H3><A NAME="SEC316" HREF="gtk_toc.html#TOC316">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_toolbar_get_type</B> <I>(void)</I>
<DD><A NAME="IDX534"></A>
Returns the <CODE>GtkToolbar</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_toolbar_new</B> <I>(GtkOrientation <VAR>orientation</VAR>, GtkToolbarStyle <VAR>style</VAR>)</I>
<DD><A NAME="IDX535"></A>
Create a new <CODE>GtkToolbar</CODE> object initializing it with the values
<VAR>orientation</VAR> and <VAR>style</VAR>. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_toolbar_append_item</B> <I>(GtkToolbar *<VAR>toolbar</VAR>, char *<VAR>text</VAR>, char *<VAR>tooltip_text</VAR>, GtkPixmap *<VAR>icon</VAR>, GtkSignalFunc <VAR>callback</VAR>, gpointer <VAR>user_data</VAR>)</I>
<DD><A NAME="IDX536"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_toolbar_prepend_item</B> <I>(GtkToolbar *<VAR>toolbar</VAR>, char *<VAR>text</VAR>, char *<VAR>tooltip_text</VAR>, GtkPixmap *<VAR>icon</VAR>, GtkSignalFunc <VAR>callback</VAR>, gpointer <VAR>user_data</VAR>)</I>
<DD><A NAME="IDX537"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_toolbar_insert_item</B> <I>(GtkToolbar *<VAR>toolbar</VAR>, char *<VAR>text</VAR>, char *<VAR>tooltip_text</VAR>, GtkPixmap *<VAR>icon</VAR>, GtkSignalFunc <VAR>callback</VAR>, gpointer <VAR>user_data</VAR>, gint <VAR>position</VAR>)</I>
<DD><A NAME="IDX538"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_toolbar_append_space</B> <I>(GtkToolbar *<VAR>toolbar</VAR>)</I>
<DD><A NAME="IDX539"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_toolbar_prepend_space</B> <I>(GtkToolbar *<VAR>toolbar</VAR>)</I>
<DD><A NAME="IDX540"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_toolbar_insert_space</B> <I>(GtkToolbar *<VAR>toolbar</VAR>, gint <VAR>position</VAR>)</I>
<DD><A NAME="IDX541"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_toolbar_set_orientation</B> <I>(GtkToolbar *<VAR>toolbar</VAR>, GtkOrientation <VAR>orientation</VAR>)</I>
<DD><A NAME="IDX542"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_toolbar_set_style</B> <I>(GtkToolbar *<VAR>toolbar</VAR>, GtkToolbarStyle <VAR>style</VAR>)</I>
<DD><A NAME="IDX543"></A>
Set the <VAR>style</VAR> of the <VAR>toolbar</VAR> to <VAR>style</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_toolbar_set_space_size</B> <I>(GtkToolbar *<VAR>toolbar</VAR>, gint <VAR>space_size</VAR>)</I>
<DD><A NAME="IDX544"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_toolbar_set_tooltips</B> <I>(GtkToolbar *<VAR>toolbar</VAR>, gint <VAR>enable</VAR>)</I>
<DD><A NAME="IDX545"></A>
</DL>

</P>

<P>
@gtkstdmacros{Toolbar, TOOLBAR}

</P>



<H2><A NAME="SEC317" HREF="gtk_toc.html#TOC317">The tool tips widget</A></H2>



<H3><A NAME="SEC318" HREF="gtk_toc.html#TOC318">Description</A></H3>



<H3><A NAME="SEC319" HREF="gtk_toc.html#TOC319">Options</A></H3>



<H3><A NAME="SEC320" HREF="gtk_toc.html#TOC320">Signals</A></H3>



<H3><A NAME="SEC321" HREF="gtk_toc.html#TOC321">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> GtkTooltips* <B>gtk_tooltips_new</B> <I>(void)</I>
<DD><A NAME="IDX546"></A>
Create a new <CODE>GtkTooltips</CODE> object returning the new widget as a 
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkTooltips* <B>gtk_tooltips_ref</B> <I>(GtkTooltips *<VAR>tooltips</VAR>)</I>
<DD><A NAME="IDX547"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tooltips_unref</B> <I>(GtkTooltips *<VAR>tooltips</VAR>)</I>
<DD><A NAME="IDX548"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tooltips_free_string</B> <I>(gpointer <VAR>data</VAR>, gpointer <VAR>user_data</VAR>)</I>
<DD><A NAME="IDX549"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tooltips_enable</B> <I>(GtkTooltips *<VAR>tooltips</VAR>)</I>
<DD><A NAME="IDX550"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tooltips_disable</B> <I>(GtkTooltips *<VAR>tooltips</VAR>)</I>
<DD><A NAME="IDX551"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tooltips_set_delay</B> <I>(GtkTooltips *<VAR>tooltips</VAR>, GtkWidget *<VAR>widget</VAR>, gchar *<VAR>tips_text</VAR>)</I>
<DD><A NAME="IDX552"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tooltips_set_colors</B> <I>(GtkTooltips *<VAR>tooltips</VAR>, GdkColor *<VAR>background</VAR>, GdkColor *<VAR>foreground</VAR>)</I>
<DD><A NAME="IDX553"></A>
</DL>

</P>

<P>
@gtkstdmacros{Tooltips, TOOLTIPS}

</P>



<H2><A NAME="SEC322" HREF="gtk_toc.html#TOC322">The tree widget</A></H2>



<H3><A NAME="SEC323" HREF="gtk_toc.html#TOC323">Description</A></H3>



<H3><A NAME="SEC324" HREF="gtk_toc.html#TOC324">Options</A></H3>



<H3><A NAME="SEC325" HREF="gtk_toc.html#TOC325">Signals</A></H3>



<H3><A NAME="SEC326" HREF="gtk_toc.html#TOC326">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_tree_get_type</B> <I>(void)</I>
<DD><A NAME="IDX554"></A>
Returns the <CODE>GtkTree</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_tree_new</B> <I>(void)</I>
<DD><A NAME="IDX555"></A>
Create a new <CODE>GtkTree</CODE> object returning the new widget as a pointer to
a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_append</B> <I>(GtkTree *<VAR>tree</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX556"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_prepend</B> <I>(GtkTree *<VAR>tree</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX557"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_insert</B> <I>(GtkTree *<VAR>tree</VAR>, GtkWidget *<VAR>child</VAR>, gint <VAR>position</VAR>)</I>
<DD><A NAME="IDX558"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_tree_child_position</B> <I>(GtkTree *<VAR>tree</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX559"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_clear_items</B> <I>(GtkTree *<VAR>tree</VAR>, gint <VAR>start</VAR>, gint <VAR>end</VAR>)</I>
<DD><A NAME="IDX560"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_remove_items</B> <I>(GtkTree *<VAR>tree</VAR>, GList *<VAR>items</VAR>)</I>
<DD><A NAME="IDX561"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_select_child</B> <I>(GtkTree *<VAR>tree</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX562"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_select_item</B> <I>(GtkTree *<VAR>tree</VAR>, gint <VAR>item</VAR>)</I>
<DD><A NAME="IDX563"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_unselect_child</B> <I>(GtkTree *<VAR>tree</VAR>, GtkWidget *<VAR>child</VAR>)</I>
<DD><A NAME="IDX564"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_unselect_item</B> <I>(GtkTree *<VAR>tree</VAR>, gint <VAR>item</VAR>)</I>
<DD><A NAME="IDX565"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_set_selection_mode</B> <I>(GtkTree *<VAR>tree</VAR>, GtkSelectionMode <VAR>mode</VAR>)</I>
<DD><A NAME="IDX566"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_set_view_mode</B> <I>(GtkTree *<VAR>tree</VAR>, GtkTreeViewMode <VAR>mode</VAR>)</I>
<DD><A NAME="IDX567"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_set_view_lines</B> <I>(GtkTree *<VAR>tree</VAR>, guint <VAR>flag</VAR>)</I>
<DD><A NAME="IDX568"></A>
</DL>

</P>

<P>
@gtkstdmacros{Tree, TREE}

</P>



<H2><A NAME="SEC327" HREF="gtk_toc.html#TOC327">The tree item widget</A></H2>



<H3><A NAME="SEC328" HREF="gtk_toc.html#TOC328">Description</A></H3>



<H3><A NAME="SEC329" HREF="gtk_toc.html#TOC329">Options</A></H3>



<H3><A NAME="SEC330" HREF="gtk_toc.html#TOC330">Signals</A></H3>



<H3><A NAME="SEC331" HREF="gtk_toc.html#TOC331">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_tree_item_get_type</B> <I>(void)</I>
<DD><A NAME="IDX569"></A>
Returns the <CODE>GtkTreeItem</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_tree_item_new</B> <I>(void)</I>
<DD><A NAME="IDX570"></A>
Create a new <CODE>GtkTreeItem</CODE> object returning the new widget as a 
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_tree_item_new_with_label</B> <I>(gchar *<VAR>label</VAR>)</I>
<DD><A NAME="IDX571"></A>
Create a new <CODE>GtkTreeItem</CODE> object initializing it with the values in
<VAR>label</VAR>. The new widget is returned as a pointer to a <CODE>GtkWidget</CODE>
object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_item_set_subtree</B> <I>(GtkTreeItem *<VAR>tree_item</VAR>, GtkWidget *<VAR>subtree</VAR>)</I>
<DD><A NAME="IDX572"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_item_select</B> <I>(GtkTreeItem *<VAR>tree_item</VAR>)</I>
<DD><A NAME="IDX573"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_item_deselect</B> <I>(GtkTreeItem *<VAR>tree_item</VAR>)</I>
<DD><A NAME="IDX574"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_item_expand</B> <I>(GtkTreeItem *<VAR>tree_item</VAR>)</I>
<DD><A NAME="IDX575"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_item_collapse</B> <I>(GtkTreeItem *<VAR>tree_item</VAR>)</I>
<DD><A NAME="IDX576"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_tree_item_remove_subtree</B> <I>(GtkTreeItem *<VAR>item</VAR>)</I>
<DD><A NAME="IDX577"></A>
</DL>

</P>

<P>
@gtkstdmacros{TreeItem, TREE_ITEM}

</P>


<H2><A NAME="SEC332" HREF="gtk_toc.html#TOC332">The vertical box widget</A></H2>



<H3><A NAME="SEC333" HREF="gtk_toc.html#TOC333">Description</A></H3>



<H3><A NAME="SEC334" HREF="gtk_toc.html#TOC334">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>homogeneous</B>
<DD><A NAME="IDX578"></A>
This option controls whether each object in the box has the same size. In the
case of the <CODE>GtkVBox</CODE>, this refers to the height. If this option is set
then the <VAR>expand</VAR> option to the <CODE>gtk_box_pack</CODE> (see section <A HREF="gtk.html#SEC36">The box widget</A>) 
routines is always turned on.
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>spacing</B>
<DD><A NAME="IDX579"></A>
This option sets the amount of space that is added between the objects packed
into this <CODE>GtkVBox</CODE> object.
</DL>

</P>



<H3><A NAME="SEC335" HREF="gtk_toc.html#TOC335">Signals</A></H3>
<P>
This widget does not define any new signals.

</P>


<H3><A NAME="SEC336" HREF="gtk_toc.html#TOC336">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_vbox_get_type</B> <I>(void)</I>
<DD><A NAME="IDX580"></A>
Returns the <CODE>GtkVBox</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_vbox_new</B> <I>(gint <VAR>homogeneous</VAR>, gint <VAR>spacing</VAR>)</I>
<DD><A NAME="IDX581"></A>
Create a new <CODE>GtkVBox</CODE> object initializing it with the values in 
<VAR>homogeneous</VAR> and <VAR>spacing</VAR>. The new widget is returned as a 
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
@gtkstdmacros{VBox, VBOX}

</P>


<H2><A NAME="SEC337" HREF="gtk_toc.html#TOC337">The vertical button box widget</A></H2>



<H3><A NAME="SEC338" HREF="gtk_toc.html#TOC338">Description</A></H3>



<H3><A NAME="SEC339" HREF="gtk_toc.html#TOC339">Options</A></H3>
<P>
<DL>
<DT><U>User Option:</U> <B>spacing</B>
<DD><A NAME="IDX582"></A>
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>layout</B>
<DD><A NAME="IDX583"></A>
</DL>

</P>


<H3><A NAME="SEC340" HREF="gtk_toc.html#TOC340">Signals</A></H3>



<H3><A NAME="SEC341" HREF="gtk_toc.html#TOC341">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_vbutton_box_get_type</B> <I>(void)</I>
<DD><A NAME="IDX584"></A>
Returns the <CODE>GtkVButtonBox</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_vbutton_box_new</B> <I>(void)</I>
<DD><A NAME="IDX585"></A>
Create a new <CODE>GtkVButtonBox</CODE> object returning the new widget as a
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_vbutton_box_set_spacing_default</B> <I>(gint <VAR>spacing</VAR>)</I>
<DD><A NAME="IDX586"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_vbutton_box_set_layout_default</B> <I>(gint <VAR>layout</VAR>)</I>
<DD><A NAME="IDX587"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_vbutton_box_get_spacing_default</B> <I>(void)</I>
<DD><A NAME="IDX588"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_vbutton_box_get_layout_default</B> <I>(void)</I>
<DD><A NAME="IDX589"></A>
</DL>

</P>
<P>
@gtkstdmacros{VButtonBox, VBUTTON_BOX}

</P>



<H2><A NAME="SEC342" HREF="gtk_toc.html#TOC342">The viewport widget</A></H2>



<H3><A NAME="SEC343" HREF="gtk_toc.html#TOC343">Description</A></H3>



<H3><A NAME="SEC344" HREF="gtk_toc.html#TOC344">Signals</A></H3>



<H3><A NAME="SEC345" HREF="gtk_toc.html#TOC345">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_viewport_get_type</B> <I>(void)</I>
<DD><A NAME="IDX590"></A>
Returns the <CODE>GtkViewport</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_viewport_new</B> <I>(GtkAdjustment *<VAR>hadjustment</VAR>, GtkAdjustment *<VAR>vadjustment</VAR>)</I>
<DD><A NAME="IDX591"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkAdjustment* <B>gtk_viewport_get_hadjustment</B> <I>(GtkViewport *<VAR>viewport</VAR>)</I>
<DD><A NAME="IDX592"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkAdjustment* <B>gtk_viewport_get_vadjustment</B> <I>(GtkViewport *<VAR>viewport</VAR>)</I>
<DD><A NAME="IDX593"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_viewport_set_hadjustment</B> <I>(GtkViewport *<VAR>viewport</VAR>, GtkAdjustment *<VAR>adjustment</VAR>)</I>
<DD><A NAME="IDX594"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_viewport_set_vadjustment</B> <I>(GtkViewport *<VAR>viewport</VAR>, GtkAdjustment *<VAR>adjustment</VAR>)</I>
<DD><A NAME="IDX595"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_viewport_set_shadow_type</B> <I>(GtkViewport *<VAR>viewport</VAR>, GtkShadowType <VAR>type</VAR>)</I>
<DD><A NAME="IDX596"></A>
</DL>

</P>
<P>
@gtkstdmacros{Viewport, VIEWPORT}

</P>


<H2><A NAME="SEC346" HREF="gtk_toc.html#TOC346">The vertical paned widget</A></H2>



<H3><A NAME="SEC347" HREF="gtk_toc.html#TOC347">Description</A></H3>



<H3><A NAME="SEC348" HREF="gtk_toc.html#TOC348">Options</A></H3>



<H3><A NAME="SEC349" HREF="gtk_toc.html#TOC349">Signals</A></H3>



<H3><A NAME="SEC350" HREF="gtk_toc.html#TOC350">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_vpaned_get_type</B> <I>(void)</I>
<DD><A NAME="IDX597"></A>
Returns the <CODE>GtkVPaned</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_vpaned_new</B> <I>(void)</I>
<DD><A NAME="IDX598"></A>
Create a new <CODE>GtkVPaned</CODE> object returning the new widget as a pointer
to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
@gtkstdmacros{VPaned, VPANED}

</P>


<H2><A NAME="SEC351" HREF="gtk_toc.html#TOC351">The vertical ruler widget</A></H2>



<H3><A NAME="SEC352" HREF="gtk_toc.html#TOC352">Description</A></H3>



<H3><A NAME="SEC353" HREF="gtk_toc.html#TOC353">Options</A></H3>



<H3><A NAME="SEC354" HREF="gtk_toc.html#TOC354">Signals</A></H3>



<H3><A NAME="SEC355" HREF="gtk_toc.html#TOC355">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_vruler_get_type</B> <I>(void)</I>
<DD><A NAME="IDX599"></A>
Returns the <CODE>GtkVRuler</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_vruler_new</B> <I>(void)</I>
<DD><A NAME="IDX600"></A>
Create a new <CODE>GtkVRuler</CODE> object returning the new widget as a pointer to 
a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
@gtkstdmacros{VRuler, VRULER}

</P>



<H2><A NAME="SEC356" HREF="gtk_toc.html#TOC356">The vertical ruler widget</A></H2>



<H3><A NAME="SEC357" HREF="gtk_toc.html#TOC357">Description</A></H3>



<H3><A NAME="SEC358" HREF="gtk_toc.html#TOC358">Options</A></H3>



<H3><A NAME="SEC359" HREF="gtk_toc.html#TOC359">Signals</A></H3>



<H3><A NAME="SEC360" HREF="gtk_toc.html#TOC360">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_vscale_get_type</B> <I>(void)</I>
<DD><A NAME="IDX601"></A>
Returns the <CODE>GtkVScale</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_vscale_new</B> <I>(GtkAdjustment *<VAR>adjustment</VAR>)</I>
<DD><A NAME="IDX602"></A>
Create a new <CODE>GtkVScale</CODE> object returning the new widget as a pointer
to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
@gtkstdmacros{VScale, VSCALE}

</P>



<H2><A NAME="SEC361" HREF="gtk_toc.html#TOC361">The vertical scrollbar widget</A></H2>



<H3><A NAME="SEC362" HREF="gtk_toc.html#TOC362">Description</A></H3>



<H3><A NAME="SEC363" HREF="gtk_toc.html#TOC363">Options</A></H3>



<H3><A NAME="SEC364" HREF="gtk_toc.html#TOC364">Signals</A></H3>



<H3><A NAME="SEC365" HREF="gtk_toc.html#TOC365">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_vscrollbar_get_type</B> <I>(void)</I>
<DD><A NAME="IDX603"></A>
Returns the <CODE>GtkVScrollbar</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_vscrollbar_new</B> <I>(GtkAdjustment *<VAR>adjustment</VAR>)</I>
<DD><A NAME="IDX604"></A>
Create a new <CODE>GtkVScrollbar</CODE> object initializing it with the values in
<VAR>adjustment</VAR>. The new widget is returned as a pointer to a <CODE>GtkWidget</CODE>
object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
@gtkstdmacros{VScrollbar, VSCROLLBAR}

</P>



<H2><A NAME="SEC366" HREF="gtk_toc.html#TOC366">The vertical separator widget</A></H2>



<H3><A NAME="SEC367" HREF="gtk_toc.html#TOC367">Description</A></H3>



<H3><A NAME="SEC368" HREF="gtk_toc.html#TOC368">Signals</A></H3>



<H3><A NAME="SEC369" HREF="gtk_toc.html#TOC369">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_vseparator_get_type</B> <I>(void)</I>
<DD><A NAME="IDX605"></A>
Returns the <CODE>GtkVSeparator</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_vseparator_new</B> <I>(void)</I>
<DD><A NAME="IDX606"></A>
Create a new <CODE>GtkVSeparator</CODE> object and return the new widget as a 
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
</DL>

</P>
<P>
@gtkstdmacros{VSeparator, VSEPARATOR}

</P>



<H2><A NAME="SEC370" HREF="gtk_toc.html#TOC370">The base widget</A></H2>



<H3><A NAME="SEC371" HREF="gtk_toc.html#TOC371">Description</A></H3>



<H3><A NAME="SEC372" HREF="gtk_toc.html#TOC372">Signals</A></H3>

<P>
<DL>
<DT><U>Signal:</U> void <B>GtkWidget::show</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX607"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkWidget::hide</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX608"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkWidget::map</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX609"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkWidget::unmap</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX610"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkWidget::realize</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX611"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkWidget::unrealize</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX612"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkWidget::draw</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkRectangle *<VAR>area</VAR>)</I>
<DD><A NAME="IDX613"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkWidget::draw_focus</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX614"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkWidget::draw_default</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX615"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkWidget::size_request</B> <I>(GtkWidget *<VAR>widget</VAR>, GtkRequisition *<VAR>requisition</VAR>)</I>
<DD><A NAME="IDX616"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkWidget::size_allocate</B> <I>(GtkWidget *<VAR>widget</VAR>, GtkAllocation *<VAR>allocation</VAR>)</I>
<DD><A NAME="IDX617"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkWidget::state_changed</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX618"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::install_accelerator</B> <I>(GtkWidget *<VAR>widget</VAR>, gchar *<VAR>signal_name</VAR>, gchar <VAR>key</VAR>, guint8 <VAR>modifiers</VAR>)</I>
<DD><A NAME="IDX619"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkWidget::remove_accelerator</B> <I>(GtkWidget *<VAR>widget</VAR>, gchar *<VAR>signal_name</VAR>)</I>
<DD><A NAME="IDX620"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEvent *<VAR>event</VAR>)</I>
<DD><A NAME="IDX621"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::button_press_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventButton *<VAR>event</VAR>)</I>
<DD><A NAME="IDX622"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::button_release_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventButton *<VAR>event</VAR>)</I>
<DD><A NAME="IDX623"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::motion_notify_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventMotion *<VAR>event</VAR>)</I>
<DD><A NAME="IDX624"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::delete_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventAny *<VAR>event</VAR>)</I>
<DD><A NAME="IDX625"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::destroy_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventAny *<VAR>event</VAR>)</I>
<DD><A NAME="IDX626"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::expose_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventExpose *<VAR>event</VAR>)</I>
<DD><A NAME="IDX627"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::key_press_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventKey *<VAR>event</VAR>)</I>
<DD><A NAME="IDX628"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::key_release_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventKey *<VAR>event</VAR>)</I>
<DD><A NAME="IDX629"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::enter_notify_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventCrossing *<VAR>event</VAR>)</I>
<DD><A NAME="IDX630"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::leave_notify_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventCrossing *<VAR>event</VAR>)</I>
<DD><A NAME="IDX631"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::configure_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventConfigure *<VAR>event</VAR>)</I>
<DD><A NAME="IDX632"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::focus_in_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventFocus *<VAR>event</VAR>)</I>
<DD><A NAME="IDX633"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::focus_out_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventFocus *<VAR>event</VAR>)</I>
<DD><A NAME="IDX634"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::map_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventAny *<VAR>event</VAR>)</I>
<DD><A NAME="IDX635"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::unmap_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventAny *<VAR>event</VAR>)</I>
<DD><A NAME="IDX636"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::property_notify_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventProperty *<VAR>event</VAR>)</I>
<DD><A NAME="IDX637"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::selection_clear_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventSelection *<VAR>event</VAR>)</I>
<DD><A NAME="IDX638"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::selection_request_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventSelection *<VAR>event</VAR>)</I>
<DD><A NAME="IDX639"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::selection_notify_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventSelection *<VAR>event</VAR>)</I>
<DD><A NAME="IDX640"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::drop_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventDrop *<VAR>event</VAR>)</I>
<DD><A NAME="IDX641"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::drag_begin_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventDragBegin *<VAR>event</VAR>)</I>
<DD><A NAME="IDX642"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> gint <B>GtkWidget::other_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEventOther *<VAR>event</VAR>)</I>
<DD><A NAME="IDX643"></A>
</DL>

</P>


<H3><A NAME="SEC373" HREF="gtk_toc.html#TOC373">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_widget_get_type</B> <I>(void)</I>
<DD><A NAME="IDX644"></A>
Returns the <CODE>GtkWidget</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_class_init</B> <I>(GtkWidgetClass *<VAR>class</VAR>)</I>
<DD><A NAME="IDX645"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_init</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX646"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_destroy</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX647"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_show</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX648"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_hide</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX649"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_map</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX650"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_unmap</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX651"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_realize</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX652"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_unrealize</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX653"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_draw</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkRectangle *<VAR>area</VAR>)</I>
<DD><A NAME="IDX654"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_draw_focus</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX655"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_draw_children</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX656"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_size_request</B> <I>(GtkWidget *<VAR>widget</VAR>, GtkRequisition *<VAR>requisition</VAR>)</I>
<DD><A NAME="IDX657"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_size_allocate</B> <I>(GtkWidget *<VAR>widget</VAR>, GtkAllocation *<VAR>allocation</VAR>)</I>
<DD><A NAME="IDX658"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_install_accelerator</B> <I>(GtkWidget *<VAR>widget</VAR>, GtkAcceleratorTable *<VAR>table</VAR>, gchar *<VAR>signal_name</VAR>, gchar <VAR>key</VAR>, guint8 <VAR>modifiers</VAR>)</I>
<DD><A NAME="IDX659"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_remove_accelerator</B> <I>(GtkWidget *<VAR>widget</VAR>, GtkAcceleratorTable *<VAR>table</VAR>, gchar *<VAR>signal_name</VAR>)</I>
<DD><A NAME="IDX660"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_widget_event</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkEvent *<VAR>event</VAR>)</I>
<DD><A NAME="IDX661"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_reparent</B> <I>(GtkWidget *<VAR>widget</VAR>, GtkWidget *<VAR>new_parent</VAR>)</I>
<DD><A NAME="IDX662"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_popup</B> <I>(GtkWidget *<VAR>widget</VAR>, gint <VAR>x</VAR>, gint <VAR>y</VAR>)</I>
<DD><A NAME="IDX663"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_widget_intersect</B> <I>(GtkWidget *<VAR>widget</VAR>, GdkRectangle *<VAR>area</VAR>, GdkRectangle *<VAR>intersection</VAR>)</I>
<DD><A NAME="IDX664"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_grab_focus</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX665"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_grab_default</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX666"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_restore_state</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX667"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_set_name</B> <I>(GtkWidget *<VAR>widget</VAR>, gchar *<VAR>name</VAR>)</I>
<DD><A NAME="IDX668"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_set_state</B> <I>(GtkWidget *<VAR>widget</VAR>, GtkStateType <VAR>state</VAR>)</I>
<DD><A NAME="IDX669"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_set_sensitive</B> <I>(GtkWidget *<VAR>widget</VAR>, gint sensitive)</I>
<DD><A NAME="IDX670"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_set_parent</B> <I>(GtkWidget *<VAR>widget</VAR>, GtkWidget *<VAR>parent</VAR>)</I>
<DD><A NAME="IDX671"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_set_style</B> <I>(GtkWidget *<VAR>widget</VAR>, GtkStyle *<VAR>style</VAR>)</I>
<DD><A NAME="IDX672"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_set_uposition</B> <I>(GtkWidget *<VAR>widget</VAR>, gint <VAR>x</VAR>, gint <VAR>y</VAR>)</I>
<DD><A NAME="IDX673"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_widget_set_usize</B> <I>(GtkWidget *<VAR>widget</VAR>, gint <VAR>width</VAR>, gint <VAR>height</VAR>)</I>
<DD><A NAME="IDX674"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_widget_get_toplevel</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX675"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_widget_get_ancestor</B> <I>(GtkWidget *<VAR>widget</VAR>, gint <VAR>type</VAR>)</I>
<DD><A NAME="IDX676"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GdkColormap* <B>gtk_widget_get_colormap</B> <I>(GtkWidget *<VAR>widget</VAR>)</I>
<DD><A NAME="IDX677"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GdkVisual* <B>gtk_widget_get_visual</B> <I>(GtkWidget *<VAR>visual</VAR>)</I>
<DD><A NAME="IDX678"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkStyle* <B>gtk_widget_get_style</B> <I>(GtkWidget *<VAR>style</VAR>)</I>
<DD><A NAME="IDX679"></A>
</DL>

</P>
<P>
@gtkstdmacros{Widget, WIDGET}

</P>



<H2><A NAME="SEC374" HREF="gtk_toc.html#TOC374">The window widget</A></H2>



<H3><A NAME="SEC375" HREF="gtk_toc.html#TOC375">Description</A></H3>



<H3><A NAME="SEC376" HREF="gtk_toc.html#TOC376">Options</A></H3>

<P>
<DL>
<DT><U>User Option:</U> <B>type</B>
<DD><A NAME="IDX680"></A>
The <VAR>type</VAR> options specify how this widget will interact with the 
window manager. Currently the following types and the effect they have
on the window to window manager interaction is as follows.

<UL>

<LI>

<CODE>GTK_WINDOW_TOPLEVEL</CODE>

<UL>
<LI>

The option <CODE>GTK_WINDOW_TOPLEVEL</CODE> is usually used for the main application
window that will remain for the entire application run.
</UL>

<LI>

<CODE>GTK_WINDOW_DIALOG</CODE>

<UL>
<LI>

The option <CODE>GTK_WINDOW_DIALOG</CODE> is usually used for transient
windows. These windows will open up, gather some input or provide some 
application specific updates, then close. The window manager is free not
to provide all the 'normal' window functions to this window.
</UL>

<LI>

<CODE>GTK_WINDOW_POPUP</CODE>

<UL>
<LI>

The option <CODE>GTK_WINDOW_POPUP</CODE> is usually used for transient windows.
These windows are typically used for when no user interaction is required,
to notify the user of some condition. Other uses for these types of windows
are for 'about windows', startup windows and the like. Typically the window
manager will <STRONG>not</STRONG> provide the usual widgets that surround the 
window. At the most all that will be provided is a border. Also note that
windows that set this <VAR>type</VAR> will not be in any window list of the window
manager. Though this window will <STRONG>not</STRONG> get the kill and close widgets
of the window manager they still can receive said events and should be 
taken into account.
</UL>

</UL>

</DL>

<P>
<DL>
<DT><U>User Option:</U> <B>title</B>
<DD><A NAME="IDX681"></A>
The <VAR>title</VAR> option will set the title of the window in the window manager.
<STRONG>Note:</STRONG> On windows that have the <VAR>type</VAR> option set to 
<CODE>GTK_WINDOW_POPUP</CODE> there is a strong possibility that this will text
will not be seen.
</DL>

</P>
<P>
<DL>
<DT><U>User Option:</U> <B>position</B>
<DD><A NAME="IDX682"></A>
The <VAR>position</VAR> option will determine where the window will be displayed
when it is finally drawn to the screen. Currently the following positions 
 and the effect they have on window placement can be specified.

</P>

<UL>

<LI>

<CODE>GTK_WIN_POS_NONE</CODE>

<UL>
<LI>

This <VAR>position</VAR> type will allow the window manager full freedom, depending
on the current settings in the window manager. As to where the window will
be placed.
</UL>

<LI>

<CODE>GTK_WIN_POS_CENTER</CODE>

<UL>
<LI>

This <VAR>position</VAR> option will cause the window to center itself on the 
the screen. This option setting will take into account the <VAR>virtual screen</VAR>
size when calculating the center. This is <STRONG>not</STRONG> the same as the 
<VAR>virtual desktop</VAR> setting of many window managers. It will center itself
on the current <VAR>virtual desktop</VAR>.
</UL>

<LI>

<CODE>GTK_WIN_POS_MOUSE</CODE>

<UL>
This <VAR>position</VAR> option will cause the window to center itself under the 
mouse pointers' current location. Typical uses for this setting is in 
warning/error/informational dialogs where user interaction is desired.
</UL>

</UL>

</DL>



<H3><A NAME="SEC377" HREF="gtk_toc.html#TOC377">Signals</A></H3>

<P>
<DL>
<DT><U>Signal:</U> void <B>GtkWindow::move_resize</B> <I>(GtkWindow *<VAR>window</VAR>, gint *<VAR>x</VAR>, gint *<VAR>y</VAR>, gint <VAR>width</VAR>, gint <VAR>height</VAR>)</I>
<DD><A NAME="IDX683"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Signal:</U> void <B>GtkWindow::set_focus</B> <I>(GtkWindow *<VAR>window</VAR>, GtkWidget *<VAR>focus</VAR>)</I>
<DD><A NAME="IDX684"></A>
</DL>

</P>


<H3><A NAME="SEC378" HREF="gtk_toc.html#TOC378">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_window_get_type</B> <I>(void)</I>
<DD><A NAME="IDX685"></A>
Returns the <CODE>GtkWindow</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkWidget* <B>gtk_window_new</B> <I>(GtkWindowType <VAR>type</VAR>)</I>
<DD><A NAME="IDX686"></A>
Create a new <CODE>GtkWindow</CODE> object. The new widget is returned as a 
pointer to a <CODE>GtkWidget</CODE> object. <CODE>NULL</CODE> is returned on failure.
The <VAR>type</VAR> can be one of <CODE>GTK_WINDOW_TOPLEVEL</CODE>, 
<CODE>GTK_WINDOW_DIALOG</CODE> or, <CODE>GTK_WINDOW_POPUP</CODE>. The <VAR>type</VAR> 
value determines how this widget will interact with the window manager.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_window_set_title</B> <I>(GtkWindow *<VAR>window</VAR>, gchar *<VAR>title</VAR>)</I>
<DD><A NAME="IDX687"></A>
Set the title of this window to the text in the <VAR>title</VAR> argument. It is 
important to not set the fields of the <CODE>GtkWindow</CODE> structure directly.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_window_set_focus</B> <I>(GtkWindow *<VAR>window</VAR>, GtkWidget *<VAR>focus</VAR>)</I>
<DD><A NAME="IDX688"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_window_set_default</B> <I>(GtkWindow *<VAR>window</VAR>, GtkWidget *<VAR>defaultw</VAR>)</I>
<DD><A NAME="IDX689"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_window_set_policy</B> <I>(GtkWindow *<VAR>window</VAR>, gint <VAR>allow_shrink</VAR>, gint <VAR>allow_grow</VAR>, gint <VAR>auto_shrink</VAR>)</I>
<DD><A NAME="IDX690"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_window_add_accelerator_table</B> <I>(GtkWindow *<VAR>window</VAR>, GtkAcceleratorTable *<VAR>table</VAR>)</I>
<DD><A NAME="IDX691"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_window_remove_accelerator_table</B> <I>(GtkWindow *<VAR>window</VAR>, GtkAcceleratorTable *<VAR>table</VAR>)</I>
<DD><A NAME="IDX692"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_window_position</B> <I>(GtkWindow *<VAR>window</VAR>, GtkWindowPosition <VAR>position</VAR>)</I>
<DD><A NAME="IDX693"></A>
Set the position that the window will be at when it is finally drawn to the
screen. The <VAR>position</VAR> argument effects the the position as described
above.
</DL>

</P>
<P>
@gtkstdmacros{Window, WINDOW}

</P>



<H1><A NAME="SEC379" HREF="gtk_toc.html#TOC379">Utility objects</A></H1>



<H2><A NAME="SEC380" HREF="gtk_toc.html#TOC380">The accelerator table object</A></H2>



<H3><A NAME="SEC381" HREF="gtk_toc.html#TOC381">Description</A></H3>



<H3><A NAME="SEC382" HREF="gtk_toc.html#TOC382">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> GtkAcceleratorTable* <B>gtk_accelerator_table_new</B> <I>(void)</I>
<DD><A NAME="IDX694"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkAcceleratorTable* <B>gtk_accelerator_table_find</B> <I>(GtkObject *<VAR>object</VAR>, gchar *<VAR>signal_name</VAR>, guchar <VAR>accelerator_key</VAR>, guint8 <VAR>accelerator_mods</VAR>)</I>
<DD><A NAME="IDX695"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkAccelerator <B>*gtk_accelerator_table_ref</B> <I>(GtkAcceleratorTable *<VAR>table</VAR>)</I>
<DD><A NAME="IDX696"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_accelerator_table_unref</B> <I>(GtkAcceleratorTable *<VAR>table</VAR>)</I>
<DD><A NAME="IDX697"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_accelerator_table_install</B> <I>(GtkAcceleratorTable *<VAR>table</VAR>, GtkObject *<VAR>object</VAR>, gchar *<VAR>signal_name</VAR>, guchar <VAR>accelerator_key</VAR>, guint8 <VAR>accelerator_mods</VAR>)</I>
<DD><A NAME="IDX698"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_accelerator_table_remove</B> <I>(GtkAcceleratorTable *<VAR>table</VAR>, GtkObject *<VAR>object</VAR>, gchar *<VAR>signal_name</VAR>)</I>
<DD><A NAME="IDX699"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_accelerator_table_check</B> <I>(GtkAcceleratorTable *<VAR>table</VAR>, guchar <VAR>accelerator_key</VAR>, guint8 <VAR>accelerator_mods</VAR>)</I>
<DD><A NAME="IDX700"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_accelerator_table_set_mod_mask</B> <I>(GtkAcceleratorTable *<VAR>table</VAR>, guint8 <VAR>modifier_mask</VAR>)</I>
<DD><A NAME="IDX701"></A>
</DL>

</P>


<H2><A NAME="SEC383" HREF="gtk_toc.html#TOC383">The adjustment object</A></H2>



<H3><A NAME="SEC384" HREF="gtk_toc.html#TOC384">Description</A></H3>



<H3><A NAME="SEC385" HREF="gtk_toc.html#TOC385">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_adjustment_get_type</B> <I>(void)</I>
<DD><A NAME="IDX702"></A>
Returns the <CODE>GtkAdjustment</CODE> type identifier.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> GtkObject* <B>gtk_adjustment_new</B> <I>(gfloat <VAR>value</VAR>, gfloat <VAR>lower</VAR>, gfloat <VAR>upper</VAR>, gfloat <VAR>step_increment</VAR>, gfloat <VAR>page_increment</VAR>, gfloat <VAR>page_size</VAR>)</I>
<DD><A NAME="IDX703"></A>
</DL>

</P>
<P>
@gtkstdmacros{GtkAdjustment, ADJUSTMENT}

</P>


<H2><A NAME="SEC386" HREF="gtk_toc.html#TOC386">The GC object</A></H2>



<H3><A NAME="SEC387" HREF="gtk_toc.html#TOC387">Description</A></H3>



<H3><A NAME="SEC388" HREF="gtk_toc.html#TOC388">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> GdkGC* <B>gtk_gc_get</B> <I>(gint <VAR>depth</VAR>, GdkColormap *<VAR>colormap</VAR>, GdkGCValues *<VAR>values</VAR>, GdkGCValuesMask <VAR>values_mask</VAR>)</I>
<DD><A NAME="IDX704"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_gc_release</B> <I>(GdkGC *<VAR>gc</VAR>)</I>
<DD><A NAME="IDX705"></A>
</DL>

</P>


<H2><A NAME="SEC389" HREF="gtk_toc.html#TOC389">The data object</A></H2>



<H3><A NAME="SEC390" HREF="gtk_toc.html#TOC390">Description</A></H3>



<H3><A NAME="SEC391" HREF="gtk_toc.html#TOC391">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_data_get_type</B> <I>(void)</I>
<DD><A NAME="IDX706"></A>
Returns the <CODE>GtkData</CODE> type identifier.
</DL>

</P>
<P>
@gtkstdmacros{Data, DATA}


<H2><A NAME="SEC392" HREF="gtk_toc.html#TOC392">The style object</A></H2>



<H3><A NAME="SEC393" HREF="gtk_toc.html#TOC393">Description</A></H3>



<H3><A NAME="SEC394" HREF="gtk_toc.html#TOC394">Functions</A></H3>



<H1><A NAME="SEC395" HREF="gtk_toc.html#TOC395">Initialization, exit and other features</A></H1>



<H2><A NAME="SEC396" HREF="gtk_toc.html#TOC396">Initializing and exiting GTK</A></H2>



<H3><A NAME="SEC397" HREF="gtk_toc.html#TOC397">Initializing</A></H3>
<P>
Before any GTK functions can be utilized the library must be initialized. This
can be accomplished by calling the <CODE>gtk_init</CODE> function. The arguments
you pass to this function should be the same arguments that were passed to
your application. This function will parse the arguments that it understands
and handle initializing the GDK library for you.

</P>


<H3><A NAME="SEC398" HREF="gtk_toc.html#TOC398">Exiting</A></H3>



<H3><A NAME="SEC399" HREF="gtk_toc.html#TOC399">Functions</A></H3>

<P>
<DL>
<DT><U>Function:</U> void <B>gtk_init</B> <I>(int *<VAR>argc</VAR>, char **<VAR>argv</VAR>)</I>
<DD><A NAME="IDX707"></A>
Function to initialize GTK and GDK for you. This function will remove any
command line arguments from <VAR>argc</VAR> and <VAR>argv</VAR> that it understands.

</P>

<PRE>
int main (int argc, char *argv[])
{
   @dots{Any local variables or non GTK/GDK initialization}

   /* Initialize GTK. */
   gtk_init(&#38;argc, &#38;argc);
   
}
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> void <B>gtk_exit</B> <I>(int <VAR>error_code</VAR>)</I>
<DD><A NAME="IDX708"></A>
Exit GTK and perform any necessary cleanup. <CODE>gtk_exit</CODE> will call the
systems <CODE>exit</CODE> function passing <VAR>error_code</VAR> as the parameter.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>gtk_events_pending</B> <I>(void)</I>
<DD><A NAME="IDX709"></A>
Returns the number of events pending on the event queue.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_main</B> <I>(void)</I>
<DD><A NAME="IDX710"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> guint <B>gtk_main_level</B> <I>(void)</I>
<DD><A NAME="IDX711"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_main_quit</B> <I>(void)</I>
<DD><A NAME="IDX712"></A>
A call to this function will cause the <CODE>gtk_main</CODE> function to exit, 
thereby allowing your application to exit.
</DL>

</P>


<H2><A NAME="SEC400" HREF="gtk_toc.html#TOC400">Customization of the library</A></H2>



<H3><A NAME="SEC401" HREF="gtk_toc.html#TOC401">Description</A></H3>
<P>
Like other X-windows applications the GTK library provides a way for the
user and application programmer to change the colors of just about any widget. 
You can also specify what pixmap should be tiled onto the background of some
widgets. All this is handled through a similar method as in the standard 
X-windows environment, through the use of 'rc' files. The format and 
functions available in these files is discussed below.

</P>


<H3><A NAME="SEC402" HREF="gtk_toc.html#TOC402">Functions</A></H3>
<P>
The following functions are available to handle the rc files.

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_rc_parse</B> <I>(char *<VAR>filename</VAR>)</I>
<DD><A NAME="IDX713"></A>
This function will parse the <VAR>filename</VAR> that is passed to it as its 
argument. It will use the style settings for the widget types defined there.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>gtk_rc_init</B> <I>(void)</I>
<DD><A NAME="IDX714"></A>
This function will initialize the rc file parser, normally this need not
be called directly as the <CODE>gtk_rc_parse</CODE> function will handle this for
you.
</DL>

</P>


<H2><A NAME="SEC403" HREF="gtk_toc.html#TOC403">Simplified menu creation</A></H2>



<H2><A NAME="SEC404" HREF="gtk_toc.html#TOC404">Simplified tree creation</A></H2>



<H2><A NAME="SEC405" HREF="gtk_toc.html#TOC405">Pop up help mechanism</A></H2>



<H3><A NAME="SEC406" HREF="gtk_toc.html#TOC406">Description</A></H3>



<H2><A NAME="SEC407" HREF="gtk_toc.html#TOC407">Resource Files</A></H2>



<H2><A NAME="SEC408" HREF="gtk_toc.html#TOC408">Macros defined by all objects</A></H2>

<P>
There are three macros that are defined by all object types. The first
two are used for performing casts and the last is for querying whether
an object is of a particular type. These macros are both conveniences
and debugging tools. If the GTK library was compiled with <CODE>NDEBUG</CODE>
defined as a preprocessor symbol (via the -DNDEBUG to cc), then the
macros check the object type and emit a warning if the cast is
invalid. Doing such checking is fairly expensive since the cast macros
are used everywhere in GTK and would normally be turned off in a public
release of a product. Note: The functions below are indeed macros, but
they may be considered functions for most purposes.

</P>
<P>
<DL>
<DT><U>Function:</U> Gtk&#60;ObjectType&#62;* <B>GTK_&#60;OBJECT_TYPE&#62;</B> <I>(gpointer <VAR>obj</VAR>)</I>
<DD><A NAME="IDX715"></A>
Cast a generic pointer to <CODE>Gtk&#60;ObjectType&#62;*</CODE>. This function is
provided in order to be able to provide checking during development
stages of code development since it is possible to examine the actual
type of object (using <CODE>gtk_type_is_a</CODE>) before performing the cast.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> Gtk&#60;ObjectType&#62;Class* <B>GTK_&#60;OBJECT_TYPE&#62;_CLASS</B> <I>(gpointer <VAR>class</VAR>)</I>
<DD><A NAME="IDX716"></A>
Cast a generic pointer to <CODE>Gtk&#60;ObjectType&#62;Class*</CODE>. Like
<CODE>GTK_&#60;ObjectType&#62;</CODE>, this function is, in reality, a macro.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> gint <B>GTK_IS_&#60;ObjectType&#62;</B> <I>(gpointer <VAR>obj</VAR>)</I>
<DD><A NAME="IDX717"></A>
Determine if a generic pointer refers to a <CODE>Gtk&#60;ObjectType&#62;</CODE>
object. This function is, in reality, a macro wrapper around the
<CODE>gtk_type_is_a</CODE> function (see section <A HREF="gtk.html#SEC3">Types</A>).
</DL>

</P>



<H1><A NAME="SEC409" HREF="gtk_toc.html#TOC409">Using GTK</A></H1>
<P>
<A NAME="IDX718"></A>

</P>



<H2><A NAME="SEC410" HREF="gtk_toc.html#TOC410">The simplest GTK program</A></H2>

<P>
The 16 line GTK program shown below is just about the simplest possible
program which uses GTK. (Well, technically, you don't have to create the
window and it would still be a program which uses GTK). The program,
when compiled and run, will create a single window 200x200 pixels in
size. The program does not exit until its is explicitly killed using the
shell or a window manager function.

</P>

<PRE>
#include &#60;gtk/gtk.h&#62;

int
main (int argc, char *argv[])
{
  GtkWidget *window;

  gtk_init (&#38;argc, &#38;argv);

  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_widget_show (window);

  gtk_main ();

  return 0;
}
</PRE>

<P>
The first point of interest in this program is the standard
initialization line.

</P>

<PRE>
  gtk_init (&#38;argc, &#38;argv);
</PRE>

<P>
Almost every GTK program will contain such a line. GTK will initialize
itself and GDK and remove any command line arguments it recognizes from
<VAR>argc</VAR> and <VAR>argv</VAR>.

</P>
<P>
The next two lines of code create and display a window.

</P>

<PRE>
  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_widget_show (window);
</PRE>

<P>
The <CODE>GTK_WINDOW_TOPLEVEL</CODE> argument specifies that we want the
window to undergo window manager decoration and placement. One might be
lead to think that the window, since it has no children, would be 0x0
pixels in size. But, this is not the case because a window that has no
children defaults to 200x200 pixels in size. Mainly because 0x0 windows
are annoying to manipulate or even see in some cases.

</P>
<P>
The last line enters the GTK main processing loop.

</P>

<PRE>
  gtk_main ();
</PRE>

<P>
Normally, <CODE>gtk_main</CODE> is called once and the program should exit
when it returns. See section <A HREF="gtk.html#SEC396">Initializing and exiting GTK</A>.

</P>



<H2><A NAME="SEC411" HREF="gtk_toc.html#TOC411">Hello world in GTK</A></H2>


<PRE>
#include &#60;gtk/gtk.h&#62;

int
main (int argc, char *argv[])
{
  GtkWidget *window;
  GtkWidget *label;

  gtk_init (&#38;argc, &#38;argv);

  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_container_border_width (GTK_CONTAINER (window), 10);

  label = gtk_label_new ("Hello World");
  gtk_container_add (GTK_CONTAINER (window), label);
  gtk_widget_show (label);

  gtk_widget_show (window);

  gtk_main ();

  return 0;
}
</PRE>



<H2><A NAME="SEC412" HREF="gtk_toc.html#TOC412">An enhanced hello world</A></H2>


<PRE>
#include "gtk.h"

void
hello (void)
{
  g_print ("Hello World\n");
  gtk_exit (0);
}

int
main (int argc, char *argv[])
{
  GtkWidget *window;
  GtkWidget *button;

  gtk_init (&#38;argc, &#38;argv);

  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_container_border_width (GTK_CONTAINER (window), 10);

  button = gtk_button_new_with_label ("Hello World");
  gtk_signal_connect (GTK_OBJECT (button), "clicked",
		      GTK_SIGNAL_FUNC (hello), NULL);
  gtk_container_add (GTK_CONTAINER (window), button);
  gtk_widget_show (button);

  gtk_widget_show (window);

  gtk_main ();

  return 0;
}
</PRE>



<H2><A NAME="SEC413" HREF="gtk_toc.html#TOC413">Making Hello World II robust</A></H2>


<PRE>
#include "gtk.h"

void
hello (void)
{
  g_print ("Hello World\n");
  gtk_exit (0);
}

void
destroy (void)
{
  gtk_exit (0);
}

int
main (int argc, char *argv[])
{
  GtkWidget *window;
  GtkWidget *button;

  gtk_init (&#38;argc, &#38;argv);

  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_signal_connect (GTK_OBJECT (window), "destroy",
		      GTK_SIGNAL_FUNC (destroy), NULL);
  gtk_container_border_width (GTK_CONTAINER (window), 10);

  button = gtk_button_new_with_label ("Hello World");
  gtk_signal_connect (GTK_OBJECT (button), "clicked",
		      GTK_SIGNAL_FUNC (hello), NULL);
  gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
			     GTK_SIGNAL_FUNC (gtk_widget_destroy),
			     GTK_OBJECT (window));
  gtk_container_add (GTK_CONTAINER (window), button);
  gtk_widget_show (button);

  gtk_widget_show (window);

  gtk_main ();

  return 0;
}
</PRE>



<H1><A NAME="SEC414" HREF="gtk_toc.html#TOC414">Object internals</A></H1>
<P>
<A NAME="IDX719"></A>

</P>
<P>
Objects (or the <CODE>GtkObject</CODE> type) and the class hierarchy in
general is implemented via a hierarchy of structs and type casting. Be
aware that when classes are mentioned it is the conceptual idea of
classes that is being referred to. GTK is written entirely in C which
provides no direct support for classes.

</P>
<P>
The first part to the class mechanism is the object fields. These are
fields that will be used on a per object basis. For example, the widget
type contains a field for the widgets parent. Every derived type needs a
reference to its parent type. A descendant class of <CODE>GtkObject</CODE>
would define itself like:

</P>

<PRE>
struct Descendant
{
  GtkObject object;

  ...
};
</PRE>

<P>
It is important to note that the <CODE>GtkObject</CODE> field needs to appear
first in the descendant type structure. This allows pointers to objects
of type <CODE>Descendant</CODE> to be cast to pointers to <CODE>GtkObject</CODE>'s
and vice-versa.

</P>
<P>
The second part to the class mechanism is the class fields. These fields
are defined on a per class basis. In the case of widgets, the class
fields are all the "virtual" functions for widgets. The
<CODE>GtkObject</CODE> class defines the <CODE>destroy</CODE> virtual function and
the necessary fields for the signal mechanism as well as a field for
determining the runtime type of an object. A virtual function is
semantically the same as it is in C++. That is, the actual function that
is called is determined based on the type of the object. Or, more
specifically, the actual function call depends on the class structure
that is pointed to by the <CODE>klass</CODE> field of the <CODE>GtkObject</CODE>
structure.

</P>
<P>
To see how the class fields work it is necessary to see the object
fields for a <CODE>GtkObject</CODE>. The <CODE>GtkObject</CODE> type is defined as
follows:

</P>

<PRE>
typedef struct _GtkObject GtkObject;

struct _GtkObject
{
  guint32 flags;
  GtkObjectClass *klass;
  gpointer object_data;
};
</PRE>

<P>
The <CODE>class</CODE> field actually points to a class structure derived from
<CODE>GtkObjectClass</CODE>. By convention, each new type defines its own
class structure even if it is unnecessary. As an example, the
hypothetical <CODE>Descendant</CODE> class would define its class structure
as:

</P>

<PRE>
struct DescendantClass
{
  GtkObjectClass parent_class;

  ...
};
</PRE>

<P>
It is convention to name the parent class field (<CODE>GtkObjectClass</CODE>
in this case), <CODE>parent_class</CODE>. For the same reason as stated above
for the object structure, the parent class field must be the first field
in the class structure.

</P>
<P>
<STRONG>Note:</STRONG> GTK assumes that the first field in a structure will be
placed by the compiler at the start of the structure. This is certainly
true for gcc, however, from my precursory reading of the C standard I
was unable to come to a definite conclusion as to whether this was
required or simply done for simplicity. I'm not too worried about this
assumption, though, as every C compiler I've ever encountered would work
with GTK.

</P>
<P>
The <CODE>flags</CODE> field of the <CODE>GtkObject</CODE> structure is used to keep
track of a relatively few object flags and is also used by the
<CODE>GtkWidget</CODE> type to store additional flags. At this time, the upper
16 bits of the flags field are reserved but unused.

</P>
<P>
The <CODE>object_data</CODE> field of the <CODE>GtkObject</CODE> structure is an
opaque pointer used by the object data mechanism. In truth, it is a
pointer to the beginning of the data list which is composed of the
following structures.

</P>

<PRE>
typedef struct _GtkObjectData GtkObjectData;

struct _GtkObjectData
{
  guint id;
  gpointer data;
  GtkObjectData *next;
};
</PRE>

<P>
The data mechanism allows arbitrary data to be associated with a
character string key in any object. A hash table is used to transform
the character string key into the data id and then a search through the
list is made to see if the data exists. The assumption being that the
data list will usually be short and therefore a linear search is
OK. Future work on the data mechanism might make use of a resizable
array instead of a linked list. This would shrink the overhead of the
<CODE>GtkObjectData</CODE> structure by 4 bytes on 32 bit architectures.

</P>



<H1><A NAME="SEC415" HREF="gtk_toc.html#TOC415">Signal internals</A></H1>
<P>
<A NAME="IDX720"></A>

</P>



<H1><A NAME="SEC416" HREF="gtk_toc.html#TOC416">Widget internals</A></H1>
<P>
<A NAME="IDX721"></A>

</P>



<H1><A NAME="SEC417" HREF="gtk_toc.html#TOC417">Function Index</A></H1>

<P>
<H2>*</H2>
<DIR>
<LI><A HREF="gtk.html#IDX696">*gtk_accelerator_table_ref</A>
</DIR>
<H2>g</H2>
<DIR>
<LI><A HREF="gtk.html#IDX715">GTK_&#60;OBJECT_TYPE&#62;</A>
<LI><A HREF="gtk.html#IDX716">GTK_&#60;OBJECT_TYPE&#62;_CLASS</A>
<LI><A HREF="gtk.html#IDX1">GTK_\q\</A>
<LI><A HREF="gtk.html#IDX2">GTK_\q\_CLASS</A>
<LI><A HREF="gtk.html#IDX700">gtk_accelerator_table_check</A>
<LI><A HREF="gtk.html#IDX695">gtk_accelerator_table_find</A>
<LI><A HREF="gtk.html#IDX698">gtk_accelerator_table_install</A>
<LI><A HREF="gtk.html#IDX694">gtk_accelerator_table_new</A>
<LI><A HREF="gtk.html#IDX699">gtk_accelerator_table_remove</A>
<LI><A HREF="gtk.html#IDX701">gtk_accelerator_table_set_mod_mask</A>
<LI><A HREF="gtk.html#IDX697">gtk_accelerator_table_unref</A>
<LI><A HREF="gtk.html#IDX702">gtk_adjustment_get_type</A>
<LI><A HREF="gtk.html#IDX703">gtk_adjustment_new</A>
<LI><A HREF="gtk.html#IDX71">gtk_alignment_get_type</A>
<LI><A HREF="gtk.html#IDX72">gtk_alignment_new</A>
<LI><A HREF="gtk.html#IDX73">gtk_alignment_set</A>
<LI><A HREF="gtk.html#IDX76">gtk_arrow_get_type</A>
<LI><A HREF="gtk.html#IDX77">gtk_arrow_new</A>
<LI><A HREF="gtk.html#IDX78">gtk_arrow_set</A>
<LI><A HREF="gtk.html#IDX84">gtk_aspect_frame_get_type</A>
<LI><A HREF="gtk.html#IDX85">gtk_aspect_frame_new</A>
<LI><A HREF="gtk.html#IDX86">gtk_aspect_frame_set</A>
<LI><A HREF="gtk.html#IDX87">gtk_bin_get_type</A>
<LI><A HREF="gtk.html#IDX92">gtk_box_get_type</A>
<LI><A HREF="gtk.html#IDX94">gtk_box_pack_end</A>
<LI><A HREF="gtk.html#IDX96">gtk_box_pack_end_defaults</A>
<LI><A HREF="gtk.html#IDX93">gtk_box_pack_start</A>
<LI><A HREF="gtk.html#IDX95">gtk_box_pack_start_defaults</A>
<LI><A HREF="gtk.html#IDX100">gtk_box_query_child_packing</A>
<LI><A HREF="gtk.html#IDX99">gtk_box_reorder_child</A>
<LI><A HREF="gtk.html#IDX101">gtk_box_set_child_packing</A>
<LI><A HREF="gtk.html#IDX97">gtk_box_set_homogeneous</A>
<LI><A HREF="gtk.html#IDX98">gtk_box_set_spacing</A>
<LI><A HREF="gtk.html#IDX117">gtk_button_box_get_child_ipadding</A>
<LI><A HREF="gtk.html#IDX111">gtk_button_box_get_child_ipadding_default</A>
<LI><A HREF="gtk.html#IDX116">gtk_button_box_get_child_size</A>
<LI><A HREF="gtk.html#IDX110">gtk_button_box_get_child_size_default</A>
<LI><A HREF="gtk.html#IDX118">gtk_button_box_get_layout</A>
<LI><A HREF="gtk.html#IDX115">gtk_button_box_get_spacing</A>
<LI><A HREF="gtk.html#IDX107">gtk_button_box_get_type</A>
<LI><A HREF="gtk.html#IDX113">gtk_button_box_set_child_ipadding</A>
<LI><A HREF="gtk.html#IDX109">gtk_button_box_set_child_ipadding_default</A>
<LI><A HREF="gtk.html#IDX112">gtk_button_box_set_child_size</A>
<LI><A HREF="gtk.html#IDX108">gtk_button_box_set_child_size_default</A>
<LI><A HREF="gtk.html#IDX114">gtk_button_box_set_layout</A>
<LI><A HREF="gtk.html#IDX129">gtk_button_clicked</A>
<LI><A HREF="gtk.html#IDX130">gtk_button_enter</A>
<LI><A HREF="gtk.html#IDX124">gtk_button_get_type</A>
<LI><A HREF="gtk.html#IDX131">gtk_button_leave</A>
<LI><A HREF="gtk.html#IDX125">gtk_button_new</A>
<LI><A HREF="gtk.html#IDX126">gtk_button_new_with_label</A>
<LI><A HREF="gtk.html#IDX127">gtk_button_pressed</A>
<LI><A HREF="gtk.html#IDX128">gtk_button_released</A>
<LI><A HREF="gtk.html#IDX135">GTK_CHECK_BUTTON</A>
<LI><A HREF="gtk.html#IDX136">GTK_CHECK_BUTTON_CLASS</A>
<LI><A HREF="gtk.html#IDX132">gtk_check_button_get_type</A>
<LI><A HREF="gtk.html#IDX133">gtk_check_button_new</A>
<LI><A HREF="gtk.html#IDX134">gtk_check_button_new_with_label</A>
<LI><A HREF="gtk.html#IDX141">gtk_check_menu_item_get_type</A>
<LI><A HREF="gtk.html#IDX142">gtk_check_menu_item_new</A>
<LI><A HREF="gtk.html#IDX143">gtk_check_menu_item_new_with_label</A>
<LI><A HREF="gtk.html#IDX144">gtk_check_menu_item_set_state</A>
<LI><A HREF="gtk.html#IDX145">gtk_check_menu_item_toggled</A>
<LI><A HREF="gtk.html#IDX168">gtk_clist_append</A>
<LI><A HREF="gtk.html#IDX175">gtk_clist_clear</A>
<LI><A HREF="gtk.html#IDX155">gtk_clist_column_titles_hide</A>
<LI><A HREF="gtk.html#IDX154">gtk_clist_column_titles_show</A>
<LI><A HREF="gtk.html#IDX152">gtk_clist_freeze</A>
<LI><A HREF="gtk.html#IDX172">gtk_clist_get_row_data</A>
<LI><A HREF="gtk.html#IDX146">gtk_clist_get_type</A>
<LI><A HREF="gtk.html#IDX169">gtk_clist_insert</A>
<LI><A HREF="gtk.html#IDX161">gtk_clist_moveto</A>
<LI><A HREF="gtk.html#IDX147">gtk_clist_new</A>
<LI><A HREF="gtk.html#IDX148">gtk_clist_new_with_titles</A>
<LI><A HREF="gtk.html#IDX170">gtk_clist_remove</A>
<LI><A HREF="gtk.html#IDX173">gtk_clist_select_row</A>
<LI><A HREF="gtk.html#IDX166">gtk_clist_set_background</A>
<LI><A HREF="gtk.html#IDX149">gtk_clist_set_border</A>
<LI><A HREF="gtk.html#IDX158">gtk_clist_set_column_justification</A>
<LI><A HREF="gtk.html#IDX156">gtk_clist_set_column_title</A>
<LI><A HREF="gtk.html#IDX157">gtk_clist_set_column_widget</A>
<LI><A HREF="gtk.html#IDX159">gtk_clist_set_column_width</A>
<LI><A HREF="gtk.html#IDX165">gtk_clist_set_foreground</A>
<LI><A HREF="gtk.html#IDX163">gtk_clist_set_pixmap</A>
<LI><A HREF="gtk.html#IDX151">gtk_clist_set_policy</A>
<LI><A HREF="gtk.html#IDX171">gtk_clist_set_row_data</A>
<LI><A HREF="gtk.html#IDX160">gtk_clist_set_row_height</A>
<LI><A HREF="gtk.html#IDX150">gtk_clist_set_selection_mode</A>
<LI><A HREF="gtk.html#IDX167">gtk_clist_set_shift</A>
<LI><A HREF="gtk.html#IDX162">gtk_clist_set_text</A>
<LI><A HREF="gtk.html#IDX164">gtk_clist_setpixtext</A>
<LI><A HREF="gtk.html#IDX153">gtk_clist_thaw</A>
<LI><A HREF="gtk.html#IDX174">gtk_clist_unselect_row</A>
<LI><A HREF="gtk.html#IDX186">gtk_color_selection_dialog_get_type</A>
<LI><A HREF="gtk.html#IDX187">gtk_color_selection_dialog_new</A>
<LI><A HREF="gtk.html#IDX184">gtk_color_selection_get_color</A>
<LI><A HREF="gtk.html#IDX180">gtk_color_selection_get_type</A>
<LI><A HREF="gtk.html#IDX181">gtk_color_selection_new</A>
<LI><A HREF="gtk.html#IDX183">gtk_color_selection_set_color</A>
<LI><A HREF="gtk.html#IDX185">gtk_color_selection_set_opacity</A>
<LI><A HREF="gtk.html#IDX182">gtk_color_selection_set_update_policy</A>
<LI><A HREF="gtk.html#IDX188">gtk_combo_get_type</A>
<LI><A HREF="gtk.html#IDX189">gtk_combo_new</A>
<LI><A HREF="gtk.html#IDX193">gtk_combo_set_case_sensitive</A>
<LI><A HREF="gtk.html#IDX194">gtk_combo_set_item_string</A>
<LI><A HREF="gtk.html#IDX195">gtk_combo_set_popdown_strings</A>
<LI><A HREF="gtk.html#IDX191">gtk_combo_set_use_arrows</A>
<LI><A HREF="gtk.html#IDX192">gtk_combo_set_use_arrows_always</A>
<LI><A HREF="gtk.html#IDX190">gtk_combo_set_value_in_list</A>
<LI><A HREF="gtk.html#IDX204">gtk_container_add</A>
<LI><A HREF="gtk.html#IDX208">gtk_container_block_resize</A>
<LI><A HREF="gtk.html#IDX203">gtk_container_border_width</A>
<LI><A HREF="gtk.html#IDX211">gtk_container_check_resize</A>
<LI><A HREF="gtk.html#IDX214">gtk_container_children</A>
<LI><A HREF="gtk.html#IDX206">gtk_container_disable_resize</A>
<LI><A HREF="gtk.html#IDX207">gtk_container_enable_resize</A>
<LI><A HREF="gtk.html#IDX213">gtk_container_focus</A>
<LI><A HREF="gtk.html#IDX212">gtk_container_foreach</A>
<LI><A HREF="gtk.html#IDX202">gtk_container_get_type</A>
<LI><A HREF="gtk.html#IDX210">gtk_container_need_resize</A>
<LI><A HREF="gtk.html#IDX205">gtk_container_remove</A>
<LI><A HREF="gtk.html#IDX209">gtk_container_unblock_resize</A>
<LI><A HREF="gtk.html#IDX225">gtk_ctree_clear</A>
<LI><A HREF="gtk.html#IDX220">gtk_ctree_get_type</A>
<LI><A HREF="gtk.html#IDX223">gtk_ctree_insert</A>
<LI><A HREF="gtk.html#IDX228">gtk_ctree_is_visible</A>
<LI><A HREF="gtk.html#IDX221">gtk_ctree_new</A>
<LI><A HREF="gtk.html#IDX222">gtk_ctree_new_with_titles</A>
<LI><A HREF="gtk.html#IDX226">gtk_ctree_post_recursive</A>
<LI><A HREF="gtk.html#IDX227">gtk_ctree_pre_recursive</A>
<LI><A HREF="gtk.html#IDX224">gtk_ctree_remove</A>
<LI><A HREF="gtk.html#IDX230">gtk_curve_get_type</A>
<LI><A HREF="gtk.html#IDX235">gtk_curve_get_vector</A>
<LI><A HREF="gtk.html#IDX231">gtk_curve_new</A>
<LI><A HREF="gtk.html#IDX232">gtk_curve_reset</A>
<LI><A HREF="gtk.html#IDX237">gtk_curve_set_curve_type</A>
<LI><A HREF="gtk.html#IDX233">gtk_curve_set_gamma</A>
<LI><A HREF="gtk.html#IDX234">gtk_curve_set_range</A>
<LI><A HREF="gtk.html#IDX236">gtk_curve_set_vector</A>
<LI><A HREF="gtk.html#IDX706">gtk_data_get_type</A>
<LI><A HREF="gtk.html#IDX240">gtk_dialog_get_type</A>
<LI><A HREF="gtk.html#IDX241">gtk_dialog_new</A>
<LI><A HREF="gtk.html#IDX244">gtk_drawing_area_get_type</A>
<LI><A HREF="gtk.html#IDX245">gtk_drawing_area_new</A>
<LI><A HREF="gtk.html#IDX246">gtk_drawing_area_size</A>
<LI><A HREF="gtk.html#IDX258">gtk_entry_append_text</A>
<LI><A HREF="gtk.html#IDX262">gtk_entry_get_text</A>
<LI><A HREF="gtk.html#IDX254">gtk_entry_get_type</A>
<LI><A HREF="gtk.html#IDX255">gtk_entry_new</A>
<LI><A HREF="gtk.html#IDX256">gtk_entry_new_with_max_length</A>
<LI><A HREF="gtk.html#IDX259">gtk_entry_prepend_text</A>
<LI><A HREF="gtk.html#IDX260">gtk_entry_set_position</A>
<LI><A HREF="gtk.html#IDX257">gtk_entry_set_text</A>
<LI><A HREF="gtk.html#IDX261">gtk_entry_set_visibility</A>
<LI><A HREF="gtk.html#IDX263">gtk_event_box_get_type</A>
<LI><A HREF="gtk.html#IDX264">gtk_event_box_new</A>
<LI><A HREF="gtk.html#IDX709">gtk_events_pending</A>
<LI><A HREF="gtk.html#IDX708">gtk_exit</A>
<LI><A HREF="gtk.html#IDX270">gtk_file_selection_get_filename</A>
<LI><A HREF="gtk.html#IDX267">gtk_file_selection_get_type</A>
<LI><A HREF="gtk.html#IDX268">gtk_file_selection_new</A>
<LI><A HREF="gtk.html#IDX269">gtk_file_selection_set_filename</A>
<LI><A HREF="gtk.html#IDX271">gtk_fixed_get_type</A>
<LI><A HREF="gtk.html#IDX274">gtk_fixed_move</A>
<LI><A HREF="gtk.html#IDX272">gtk_fixed_new</A>
<LI><A HREF="gtk.html#IDX273">gtk_fixed_put_new</A>
<LI><A HREF="gtk.html#IDX279">gtk_frame_get_type</A>
<LI><A HREF="gtk.html#IDX280">gtk_frame_new</A>
<LI><A HREF="gtk.html#IDX281">gtk_frame_set_label</A>
<LI><A HREF="gtk.html#IDX282">gtk_frame_set_label_align</A>
<LI><A HREF="gtk.html#IDX283">gtk_frame_set_shadow_type</A>
<LI><A HREF="gtk.html#IDX12">GTK_FUNDAMENTAL_TYPE</A>
<LI><A HREF="gtk.html#IDX238">gtk_gamma_curve_get_type</A>, <A HREF="gtk.html#IDX284">gtk_gamma_curve_get_type</A>
<LI><A HREF="gtk.html#IDX239">gtk_gamma_curve_new</A>, <A HREF="gtk.html#IDX285">gtk_gamma_curve_new</A>
<LI><A HREF="gtk.html#IDX704">gtk_gc_get</A>
<LI><A HREF="gtk.html#IDX705">gtk_gc_release</A>
<LI><A HREF="gtk.html#IDX288">gtk_hbox_get_type</A>
<LI><A HREF="gtk.html#IDX289">gtk_hbox_new</A>
<LI><A HREF="gtk.html#IDX297">gtk_hbutton_box_get_layout_default</A>
<LI><A HREF="gtk.html#IDX296">gtk_hbutton_box_get_spacing_default</A>
<LI><A HREF="gtk.html#IDX292">gtk_hbutton_box_get_type</A>
<LI><A HREF="gtk.html#IDX293">gtk_hbutton_box_new</A>
<LI><A HREF="gtk.html#IDX295">gtk_hbutton_box_set_layout_default</A>
<LI><A HREF="gtk.html#IDX294">gtk_hbutton_box_set_spacing_default</A>
<LI><A HREF="gtk.html#IDX298">gtk_hpaned_get_type</A>
<LI><A HREF="gtk.html#IDX299">gtk_hpaned_new</A>
<LI><A HREF="gtk.html#IDX300">gtk_hruler_get_type</A>
<LI><A HREF="gtk.html#IDX301">gtk_hruler_new</A>
<LI><A HREF="gtk.html#IDX302">gtk_hscale_get_type</A>
<LI><A HREF="gtk.html#IDX303">gtk_hscale_new</A>
<LI><A HREF="gtk.html#IDX304">gtk_hscrollbar_get_type</A>
<LI><A HREF="gtk.html#IDX305">gtk_hscrollbar_new</A>
<LI><A HREF="gtk.html#IDX306">gtk_hseparator_get_type</A>
<LI><A HREF="gtk.html#IDX307">gtk_hseparator_new</A>
<LI><A HREF="gtk.html#IDX311">gtk_image_get</A>
<LI><A HREF="gtk.html#IDX308">gtk_image_get_type</A>
<LI><A HREF="gtk.html#IDX309">gtk_image_new</A>
<LI><A HREF="gtk.html#IDX310">gtk_image_set</A>
<LI><A HREF="gtk.html#IDX707">gtk_init</A>
<LI><A HREF="gtk.html#IDX314">gtk_input_dialog_get_type</A>
<LI><A HREF="gtk.html#IDX315">gtk_input_dialog_new</A>
<LI><A HREF="gtk.html#IDX717">GTK_IS_&#60;ObjectType&#62;</A>
<LI><A HREF="gtk.html#IDX3">GTK_IS_\q\</A>
<LI><A HREF="gtk.html#IDX137">GTK_IS_CHECK_BUTTON</A>
<LI><A HREF="gtk.html#IDX321">gtk_item_deselect</A>
<LI><A HREF="gtk.html#IDX319">gtk_item_get_type</A>
<LI><A HREF="gtk.html#IDX320">gtk_item_select</A>
<LI><A HREF="gtk.html#IDX322">gtk_item_toggle</A>
<LI><A HREF="gtk.html#IDX327">gtk_label_get</A>
<LI><A HREF="gtk.html#IDX324">gtk_label_get_type</A>
<LI><A HREF="gtk.html#IDX325">gtk_label_new</A>
<LI><A HREF="gtk.html#IDX326">gtk_label_set</A>
<LI><A HREF="gtk.html#IDX334">gtk_list_append_items</A>
<LI><A HREF="gtk.html#IDX342">gtk_list_child_position</A>
<LI><A HREF="gtk.html#IDX337">gtk_list_clear_items</A>
<LI><A HREF="gtk.html#IDX331">gtk_list_get_type</A>
<LI><A HREF="gtk.html#IDX333">gtk_list_insert_items</A>
<LI><A HREF="gtk.html#IDX348">gtk_list_item_deselect</A>
<LI><A HREF="gtk.html#IDX344">gtk_list_item_get_type</A>
<LI><A HREF="gtk.html#IDX345">gtk_list_item_new</A>
<LI><A HREF="gtk.html#IDX346">gtk_list_item_new_with_label</A>
<LI><A HREF="gtk.html#IDX347">gtk_list_item_select</A>
<LI><A HREF="gtk.html#IDX332">gtk_list_new</A>
<LI><A HREF="gtk.html#IDX335">gtk_list_prepend_items</A>
<LI><A HREF="gtk.html#IDX336">gtk_list_remove_items</A>
<LI><A HREF="gtk.html#IDX340">gtk_list_select_child</A>
<LI><A HREF="gtk.html#IDX338">gtk_list_select_item</A>
<LI><A HREF="gtk.html#IDX343">gtk_list_set_selection_mode</A>
<LI><A HREF="gtk.html#IDX341">gtk_list_unselect_child</A>
<LI><A HREF="gtk.html#IDX339">gtk_list_unselect_item</A>
<LI><A HREF="gtk.html#IDX710">gtk_main</A>
<LI><A HREF="gtk.html#IDX711">gtk_main_level</A>
<LI><A HREF="gtk.html#IDX712">gtk_main_quit</A>
<LI><A HREF="gtk.html#IDX351">gtk_menu_append</A>
<LI><A HREF="gtk.html#IDX362">gtk_menu_bar_append</A>
<LI><A HREF="gtk.html#IDX360">gtk_menu_bar_get_type</A>
<LI><A HREF="gtk.html#IDX364">gtk_menu_bar_insert</A>
<LI><A HREF="gtk.html#IDX361">gtk_menu_bar_new</A>
<LI><A HREF="gtk.html#IDX363">gtk_menu_bar_prepend</A>
<LI><A HREF="gtk.html#IDX356">gtk_menu_get_active</A>
<LI><A HREF="gtk.html#IDX349">gtk_menu_get_type</A>
<LI><A HREF="gtk.html#IDX353">gtk_menu_insert</A>
<LI><A HREF="gtk.html#IDX371">gtk_menu_item_accelerator_size</A>
<LI><A HREF="gtk.html#IDX372">gtk_menu_item_accelerator_text</A>
<LI><A HREF="gtk.html#IDX376">gtk_menu_item_activate</A>
<LI><A HREF="gtk.html#IDX373">gtk_menu_item_configure</A>
<LI><A HREF="gtk.html#IDX375">gtk_menu_item_deselect</A>
<LI><A HREF="gtk.html#IDX366">gtk_menu_item_get_type</A>
<LI><A HREF="gtk.html#IDX367">gtk_menu_item_new</A>
<LI><A HREF="gtk.html#IDX368">gtk_menu_item_new_with_label</A>
<LI><A HREF="gtk.html#IDX374">gtk_menu_item_select</A>
<LI><A HREF="gtk.html#IDX370">gtk_menu_item_set_placement</A>
<LI><A HREF="gtk.html#IDX369">gtk_menu_item_set_submenu</A>
<LI><A HREF="gtk.html#IDX350">gtk_menu_new</A>
<LI><A HREF="gtk.html#IDX355">gtk_menu_popdown</A>
<LI><A HREF="gtk.html#IDX354">gtk_menu_popup</A>
<LI><A HREF="gtk.html#IDX352">gtk_menu_prepend</A>
<LI><A HREF="gtk.html#IDX358">gtk_menu_set_accelerator_table</A>
<LI><A HREF="gtk.html#IDX357">gtk_menu_set_active</A>
<LI><A HREF="gtk.html#IDX379">gtk_menu_shell_append</A>
<LI><A HREF="gtk.html#IDX382">gtk_menu_shell_deactivate</A>
<LI><A HREF="gtk.html#IDX378">gtk_menu_shell_get_type</A>
<LI><A HREF="gtk.html#IDX381">gtk_menu_shell_insert</A>
<LI><A HREF="gtk.html#IDX380">gtk_menu_shell_prepend</A>
<LI><A HREF="gtk.html#IDX387">gtk_misc_get_type</A>
<LI><A HREF="gtk.html#IDX388">gtk_misc_set_alignment</A>
<LI><A HREF="gtk.html#IDX389">gtk_misc_set_padding</A>
<LI><A HREF="gtk.html#IDX392">gtk_notebook_append_page</A>
<LI><A HREF="gtk.html#IDX390">gtk_notebook_get_type</A>
<LI><A HREF="gtk.html#IDX394">gtk_notebook_insert_page</A>
<LI><A HREF="gtk.html#IDX391">gtk_notebook_new</A>
<LI><A HREF="gtk.html#IDX397">gtk_notebook_next_page</A>
<LI><A HREF="gtk.html#IDX393">gtk_notebook_prepend_page</A>
<LI><A HREF="gtk.html#IDX398">gtk_notebook_prev_page</A>
<LI><A HREF="gtk.html#IDX395">gtk_notebook_remove_page</A>
<LI><A HREF="gtk.html#IDX396">gtk_notebook_set_page</A>
<LI><A HREF="gtk.html#IDX401">gtk_notebook_set_show_border</A>
<LI><A HREF="gtk.html#IDX400">gtk_notebook_set_show_tabs</A>
<LI><A HREF="gtk.html#IDX399">gtk_notebook_set_tab_pos</A>
<LI><A HREF="gtk.html#IDX32">gtk_object_add_arg_type</A>
<LI><A HREF="gtk.html#IDX23">gtk_object_class_add_signals</A>
<LI><A HREF="gtk.html#IDX34">gtk_object_destroy</A>
<LI><A HREF="gtk.html#IDX33">gtk_object_get_arg_type</A>
<LI><A HREF="gtk.html#IDX36">gtk_object_get_data</A>
<LI><A HREF="gtk.html#IDX22">gtk_object_get_type</A>
<LI><A HREF="gtk.html#IDX39">gtk_object_get_user_data</A>
<LI><A HREF="gtk.html#IDX28">gtk_object_getv</A>
<LI><A HREF="gtk.html#IDX24">gtk_object_new</A>
<LI><A HREF="gtk.html#IDX25">gtk_object_newv</A>
<LI><A HREF="gtk.html#IDX43">gtk_object_peek_value</A>
<LI><A HREF="gtk.html#IDX42">gtk_object_pop_value</A>
<LI><A HREF="gtk.html#IDX41">gtk_object_push_value</A>
<LI><A HREF="gtk.html#IDX31">gtk_object_query_args</A>
<LI><A HREF="gtk.html#IDX26">gtk_object_ref</A>
<LI><A HREF="gtk.html#IDX37">gtk_object_remove_data</A>
<LI><A HREF="gtk.html#IDX29">gtk_object_set</A>
<LI><A HREF="gtk.html#IDX35">gtk_object_set_data</A>
<LI><A HREF="gtk.html#IDX38">gtk_object_set_user_data</A>
<LI><A HREF="gtk.html#IDX30">gtk_object_setv</A>
<LI><A HREF="gtk.html#IDX27">gtk_object_unref</A>
<LI><A HREF="gtk.html#IDX40">gtk_object_value_stack_new</A>
<LI><A HREF="gtk.html#IDX405">gtk_option_menu_get_menu</A>
<LI><A HREF="gtk.html#IDX403">gtk_option_menu_get_type</A>
<LI><A HREF="gtk.html#IDX404">gtk_option_menu_new</A>
<LI><A HREF="gtk.html#IDX407">gtk_option_menu_remove_menu</A>
<LI><A HREF="gtk.html#IDX408">gtk_option_menu_set_history</A>
<LI><A HREF="gtk.html#IDX406">gtk_option_menu_set_menu</A>
<LI><A HREF="gtk.html#IDX410">gtk_paned_add1</A>
<LI><A HREF="gtk.html#IDX411">gtk_paned_add2</A>
<LI><A HREF="gtk.html#IDX409">gtk_paned_get_type</A>
<LI><A HREF="gtk.html#IDX413">gtk_paned_gutter_size</A>
<LI><A HREF="gtk.html#IDX412">gtk_paned_handle_size</A>
<LI><A HREF="gtk.html#IDX417">gtk_pixmap_get</A>
<LI><A HREF="gtk.html#IDX414">gtk_pixmap_get_type</A>
<LI><A HREF="gtk.html#IDX415">gtk_pixmap_new</A>
<LI><A HREF="gtk.html#IDX416">gtk_pixmap_set</A>
<LI><A HREF="gtk.html#IDX427">gtk_preview_draw_row</A>
<LI><A HREF="gtk.html#IDX434">gtk_preview_get_cmap</A>
<LI><A HREF="gtk.html#IDX435">gtk_preview_get_info</A>
<LI><A HREF="gtk.html#IDX421">gtk_preview_get_type</A>
<LI><A HREF="gtk.html#IDX433">gtk_preview_get_visual</A>
<LI><A HREF="gtk.html#IDX423">gtk_preview_new</A>
<LI><A HREF="gtk.html#IDX425">gtk_preview_put</A>
<LI><A HREF="gtk.html#IDX426">gtk_preview_put_row</A>
<LI><A HREF="gtk.html#IDX430">gtk_preview_set_color_cube</A>
<LI><A HREF="gtk.html#IDX428">gtk_preview_set_expand</A>
<LI><A HREF="gtk.html#IDX429">gtk_preview_set_gamma</A>
<LI><A HREF="gtk.html#IDX431">gtk_preview_set_install_cmap</A>
<LI><A HREF="gtk.html#IDX432">gtk_preview_set_reserved</A>
<LI><A HREF="gtk.html#IDX424">gtk_preview_size</A>
<LI><A HREF="gtk.html#IDX422">gtk_preview_uninit</A>
<LI><A HREF="gtk.html#IDX437">gtk_progress_bar_get_type</A>
<LI><A HREF="gtk.html#IDX438">gtk_progress_bar_new</A>
<LI><A HREF="gtk.html#IDX439">gtk_progress_bar_update</A>
<LI><A HREF="gtk.html#IDX442">gtk_radio_button_get_type</A>
<LI><A HREF="gtk.html#IDX445">gtk_radio_button_group</A>
<LI><A HREF="gtk.html#IDX443">gtk_radio_button_new</A>
<LI><A HREF="gtk.html#IDX444">gtk_radio_button_new_with_label</A>
<LI><A HREF="gtk.html#IDX448">gtk_radio_menu_item_get_type</A>
<LI><A HREF="gtk.html#IDX451">gtk_radio_menu_item_group</A>
<LI><A HREF="gtk.html#IDX449">gtk_radio_menu_item_new</A>
<LI><A HREF="gtk.html#IDX450">gtk_radio_menu_item_new_with_label</A>
<LI><A HREF="gtk.html#IDX469">gtk_range_calc_value</A>
<LI><A HREF="gtk.html#IDX467">gtk_range_default_hmotion</A>
<LI><A HREF="gtk.html#IDX463">gtk_range_default_hslider_update</A>
<LI><A HREF="gtk.html#IDX465">gtk_range_default_htrough_click</A>
<LI><A HREF="gtk.html#IDX468">gtk_range_default_vmotion</A>
<LI><A HREF="gtk.html#IDX464">gtk_range_default_vslider_update</A>
<LI><A HREF="gtk.html#IDX466">gtk_range_default_vtrough_click</A>
<LI><A HREF="gtk.html#IDX456">gtk_range_draw_background</A>
<LI><A HREF="gtk.html#IDX458">gtk_range_draw_slider</A>
<LI><A HREF="gtk.html#IDX460">gtk_range_draw_step_back</A>
<LI><A HREF="gtk.html#IDX459">gtk_range_draw_step_forw</A>
<LI><A HREF="gtk.html#IDX457">gtk_range_draw_trough</A>
<LI><A HREF="gtk.html#IDX453">gtk_range_get_adjustment</A>
<LI><A HREF="gtk.html#IDX452">gtk_range_get_type</A>
<LI><A HREF="gtk.html#IDX455">gtk_range_set_adjustment</A>
<LI><A HREF="gtk.html#IDX454">gtk_range_set_update_policy</A>
<LI><A HREF="gtk.html#IDX461">gtk_range_slider_update</A>
<LI><A HREF="gtk.html#IDX462">gtk_range_trough_click</A>
<LI><A HREF="gtk.html#IDX714">gtk_rc_init</A>
<LI><A HREF="gtk.html#IDX713">gtk_rc_parse</A>
<LI><A HREF="gtk.html#IDX479">gtk_ruler_draw_pos</A>
<LI><A HREF="gtk.html#IDX478">gtk_ruler_draw_ticks</A>
<LI><A HREF="gtk.html#IDX475">gtk_ruler_get_type</A>
<LI><A HREF="gtk.html#IDX476">gtk_ruler_set_metric</A>
<LI><A HREF="gtk.html#IDX477">gtk_ruler_set_range</A>
<LI><A HREF="gtk.html#IDX488">gtk_scale_draw_value</A>
<LI><A HREF="gtk.html#IDX483">gtk_scale_get_type</A>
<LI><A HREF="gtk.html#IDX484">gtk_scale_set_digits</A>
<LI><A HREF="gtk.html#IDX485">gtk_scale_set_draw_value</A>
<LI><A HREF="gtk.html#IDX486">gtk_scale_set_value_pos</A>
<LI><A HREF="gtk.html#IDX487">gtk_scale_value_width</A>
<LI><A HREF="gtk.html#IDX489">gtk_scrollbar_get_type</A>
<LI><A HREF="gtk.html#IDX492">gtk_scrolled_window_get_hadjustment</A>
<LI><A HREF="gtk.html#IDX490">gtk_scrolled_window_get_type</A>
<LI><A HREF="gtk.html#IDX493">gtk_scrolled_window_get_vadjustment</A>
<LI><A HREF="gtk.html#IDX491">gtk_scrolled_window_new</A>
<LI><A HREF="gtk.html#IDX494">gtk_scrolled_window_set_policy</A>
<LI><A HREF="gtk.html#IDX495">gtk_separator_get_type</A>
<LI><A HREF="gtk.html#IDX52">gtk_signal_connect</A>
<LI><A HREF="gtk.html#IDX53">gtk_signal_connect_after</A>
<LI><A HREF="gtk.html#IDX56">gtk_signal_connect_interp</A>
<LI><A HREF="gtk.html#IDX54">gtk_signal_connect_object</A>
<LI><A HREF="gtk.html#IDX55">gtk_signal_connect_object_after</A>
<LI><A HREF="gtk.html#IDX64">gtk_signal_default_marshaller</A>
<LI><A HREF="gtk.html#IDX57">gtk_signal_disconnect</A>
<LI><A HREF="gtk.html#IDX58">gtk_signal_disconnect_by_data</A>
<LI><A HREF="gtk.html#IDX48">gtk_signal_emit</A>
<LI><A HREF="gtk.html#IDX49">gtk_signal_emit_by_name</A>
<LI><A HREF="gtk.html#IDX50">gtk_signal_emit_stop</A>
<LI><A HREF="gtk.html#IDX51">gtk_signal_emit_stop_by_name</A>
<LI><A HREF="gtk.html#IDX59">gtk_signal_handler_block</A>
<LI><A HREF="gtk.html#IDX60">gtk_signal_handler_block_by_data</A>
<LI><A HREF="gtk.html#IDX61">gtk_signal_handler_unblock</A>
<LI><A HREF="gtk.html#IDX62">gtk_signal_handler_unblock_by_data</A>
<LI><A HREF="gtk.html#IDX63">gtk_signal_handlers_destroy</A>
<LI><A HREF="gtk.html#IDX46">gtk_signal_lookup</A>
<LI><A HREF="gtk.html#IDX47">gtk_signal_name</A>
<LI><A HREF="gtk.html#IDX45">gtk_signal_new</A>
<LI><A HREF="gtk.html#IDX65">gtk_signal_set_funcs</A>
<LI><A HREF="gtk.html#IDX496">gtk_statusbar_get_type</A>
<LI><A HREF="gtk.html#IDX497">gtk_statusbar_new</A>
<LI><A HREF="gtk.html#IDX499">gtk_statusbar_pop</A>
<LI><A HREF="gtk.html#IDX498">gtk_statusbar_push</A>
<LI><A HREF="gtk.html#IDX505">gtk_table_attach</A>
<LI><A HREF="gtk.html#IDX506">gtk_table_attach_defaults</A>
<LI><A HREF="gtk.html#IDX503">gtk_table_get_type</A>
<LI><A HREF="gtk.html#IDX504">gtk_table_new</A>
<LI><A HREF="gtk.html#IDX508">gtk_table_set_col_spacing</A>
<LI><A HREF="gtk.html#IDX510">gtk_table_set_col_spacings</A>
<LI><A HREF="gtk.html#IDX507">gtk_table_set_row_spacing</A>
<LI><A HREF="gtk.html#IDX509">gtk_table_set_row_spacings</A>
<LI><A HREF="gtk.html#IDX522">gtk_text_backward_delete</A>
<LI><A HREF="gtk.html#IDX521">gtk_text_forward_delete</A>
<LI><A HREF="gtk.html#IDX518">gtk_text_freeze</A>
<LI><A HREF="gtk.html#IDX517">gtk_text_get_length</A>
<LI><A HREF="gtk.html#IDX516">gtk_text_get_point</A>
<LI><A HREF="gtk.html#IDX511">gtk_text_get_type</A>
<LI><A HREF="gtk.html#IDX520">gtk_text_insert</A>
<LI><A HREF="gtk.html#IDX512">gtk_text_new</A>
<LI><A HREF="gtk.html#IDX514">gtk_text_set_adjustments</A>
<LI><A HREF="gtk.html#IDX513">gtk_text_set_editable</A>
<LI><A HREF="gtk.html#IDX515">gtk_text_set_point</A>
<LI><A HREF="gtk.html#IDX519">gtk_text_thaw</A>
<LI><A HREF="gtk.html#IDX525">gtk_toggle_button_get_type</A>
<LI><A HREF="gtk.html#IDX526">gtk_toggle_button_new</A>
<LI><A HREF="gtk.html#IDX527">gtk_toggle_button_new_with_label</A>
<LI><A HREF="gtk.html#IDX528">gtk_toggle_button_set_mode</A>
<LI><A HREF="gtk.html#IDX529">gtk_toggle_button_set_state</A>
<LI><A HREF="gtk.html#IDX530">gtk_toggle_button_toggled</A>
<LI><A HREF="gtk.html#IDX536">gtk_toolbar_append_item</A>
<LI><A HREF="gtk.html#IDX539">gtk_toolbar_append_space</A>
<LI><A HREF="gtk.html#IDX534">gtk_toolbar_get_type</A>
<LI><A HREF="gtk.html#IDX538">gtk_toolbar_insert_item</A>
<LI><A HREF="gtk.html#IDX541">gtk_toolbar_insert_space</A>
<LI><A HREF="gtk.html#IDX535">gtk_toolbar_new</A>
<LI><A HREF="gtk.html#IDX537">gtk_toolbar_prepend_item</A>
<LI><A HREF="gtk.html#IDX540">gtk_toolbar_prepend_space</A>
<LI><A HREF="gtk.html#IDX542">gtk_toolbar_set_orientation</A>
<LI><A HREF="gtk.html#IDX544">gtk_toolbar_set_space_size</A>
<LI><A HREF="gtk.html#IDX543">gtk_toolbar_set_style</A>
<LI><A HREF="gtk.html#IDX545">gtk_toolbar_set_tooltips</A>
<LI><A HREF="gtk.html#IDX551">gtk_tooltips_disable</A>
<LI><A HREF="gtk.html#IDX550">gtk_tooltips_enable</A>
<LI><A HREF="gtk.html#IDX549">gtk_tooltips_free_string</A>
<LI><A HREF="gtk.html#IDX546">gtk_tooltips_new</A>
<LI><A HREF="gtk.html#IDX547">gtk_tooltips_ref</A>
<LI><A HREF="gtk.html#IDX553">gtk_tooltips_set_colors</A>
<LI><A HREF="gtk.html#IDX552">gtk_tooltips_set_delay</A>
<LI><A HREF="gtk.html#IDX548">gtk_tooltips_unref</A>
<LI><A HREF="gtk.html#IDX556">gtk_tree_append</A>
<LI><A HREF="gtk.html#IDX559">gtk_tree_child_position</A>
<LI><A HREF="gtk.html#IDX560">gtk_tree_clear_items</A>
<LI><A HREF="gtk.html#IDX554">gtk_tree_get_type</A>
<LI><A HREF="gtk.html#IDX558">gtk_tree_insert</A>
<LI><A HREF="gtk.html#IDX576">gtk_tree_item_collapse</A>
<LI><A HREF="gtk.html#IDX574">gtk_tree_item_deselect</A>
<LI><A HREF="gtk.html#IDX575">gtk_tree_item_expand</A>
<LI><A HREF="gtk.html#IDX569">gtk_tree_item_get_type</A>
<LI><A HREF="gtk.html#IDX570">gtk_tree_item_new</A>
<LI><A HREF="gtk.html#IDX571">gtk_tree_item_new_with_label</A>
<LI><A HREF="gtk.html#IDX577">gtk_tree_item_remove_subtree</A>
<LI><A HREF="gtk.html#IDX573">gtk_tree_item_select</A>
<LI><A HREF="gtk.html#IDX572">gtk_tree_item_set_subtree</A>
<LI><A HREF="gtk.html#IDX555">gtk_tree_new</A>
<LI><A HREF="gtk.html#IDX557">gtk_tree_prepend</A>
<LI><A HREF="gtk.html#IDX561">gtk_tree_remove_items</A>
<LI><A HREF="gtk.html#IDX562">gtk_tree_select_child</A>
<LI><A HREF="gtk.html#IDX563">gtk_tree_select_item</A>
<LI><A HREF="gtk.html#IDX566">gtk_tree_set_selection_mode</A>
<LI><A HREF="gtk.html#IDX568">gtk_tree_set_view_lines</A>
<LI><A HREF="gtk.html#IDX567">gtk_tree_set_view_mode</A>
<LI><A HREF="gtk.html#IDX564">gtk_tree_unselect_child</A>
<LI><A HREF="gtk.html#IDX565">gtk_tree_unselect_item</A>
<LI><A HREF="gtk.html#IDX17">gtk_type_class</A>
<LI><A HREF="gtk.html#IDX19">gtk_type_describe_heritage</A>
<LI><A HREF="gtk.html#IDX20">gtk_type_describe_tree</A>
<LI><A HREF="gtk.html#IDX15">gtk_type_from_name</A>
<LI><A HREF="gtk.html#IDX21">gtk_type_is_a</A>
<LI><A HREF="gtk.html#IDX14">gtk_type_name</A>
<LI><A HREF="gtk.html#IDX18">gtk_type_new</A>
<LI><A HREF="gtk.html#IDX16">gtk_type_parent</A>
<LI><A HREF="gtk.html#IDX11">GTK_TYPE_SEQNO</A>
<LI><A HREF="gtk.html#IDX13">gtk_type_unique</A>
<LI><A HREF="gtk.html#IDX580">gtk_vbox_get_type</A>
<LI><A HREF="gtk.html#IDX581">gtk_vbox_new</A>
<LI><A HREF="gtk.html#IDX589">gtk_vbutton_box_get_layout_default</A>
<LI><A HREF="gtk.html#IDX588">gtk_vbutton_box_get_spacing_default</A>
<LI><A HREF="gtk.html#IDX584">gtk_vbutton_box_get_type</A>
<LI><A HREF="gtk.html#IDX585">gtk_vbutton_box_new</A>
<LI><A HREF="gtk.html#IDX587">gtk_vbutton_box_set_layout_default</A>
<LI><A HREF="gtk.html#IDX586">gtk_vbutton_box_set_spacing_default</A>
<LI><A HREF="gtk.html#IDX592">gtk_viewport_get_hadjustment</A>
<LI><A HREF="gtk.html#IDX590">gtk_viewport_get_type</A>
<LI><A HREF="gtk.html#IDX593">gtk_viewport_get_vadjustment</A>
<LI><A HREF="gtk.html#IDX591">gtk_viewport_new</A>
<LI><A HREF="gtk.html#IDX594">gtk_viewport_set_hadjustment</A>
<LI><A HREF="gtk.html#IDX596">gtk_viewport_set_shadow_type</A>
<LI><A HREF="gtk.html#IDX595">gtk_viewport_set_vadjustment</A>
<LI><A HREF="gtk.html#IDX597">gtk_vpaned_get_type</A>
<LI><A HREF="gtk.html#IDX598">gtk_vpaned_new</A>
<LI><A HREF="gtk.html#IDX599">gtk_vruler_get_type</A>
<LI><A HREF="gtk.html#IDX600">gtk_vruler_new</A>
<LI><A HREF="gtk.html#IDX601">gtk_vscale_get_type</A>
<LI><A HREF="gtk.html#IDX602">gtk_vscale_new</A>
<LI><A HREF="gtk.html#IDX603">gtk_vscrollbar_get_type</A>
<LI><A HREF="gtk.html#IDX604">gtk_vscrollbar_new</A>
<LI><A HREF="gtk.html#IDX605">gtk_vseparator_get_type</A>
<LI><A HREF="gtk.html#IDX606">gtk_vseparator_new</A>
<LI><A HREF="gtk.html#IDX645">gtk_widget_class_init</A>
<LI><A HREF="gtk.html#IDX647">gtk_widget_destroy</A>
<LI><A HREF="gtk.html#IDX654">gtk_widget_draw</A>
<LI><A HREF="gtk.html#IDX656">gtk_widget_draw_children</A>
<LI><A HREF="gtk.html#IDX655">gtk_widget_draw_focus</A>
<LI><A HREF="gtk.html#IDX661">gtk_widget_event</A>
<LI><A HREF="gtk.html#IDX676">gtk_widget_get_ancestor</A>
<LI><A HREF="gtk.html#IDX677">gtk_widget_get_colormap</A>
<LI><A HREF="gtk.html#IDX679">gtk_widget_get_style</A>
<LI><A HREF="gtk.html#IDX675">gtk_widget_get_toplevel</A>
<LI><A HREF="gtk.html#IDX644">gtk_widget_get_type</A>
<LI><A HREF="gtk.html#IDX678">gtk_widget_get_visual</A>
<LI><A HREF="gtk.html#IDX666">gtk_widget_grab_default</A>
<LI><A HREF="gtk.html#IDX665">gtk_widget_grab_focus</A>
<LI><A HREF="gtk.html#IDX649">gtk_widget_hide</A>
<LI><A HREF="gtk.html#IDX646">gtk_widget_init</A>
<LI><A HREF="gtk.html#IDX659">gtk_widget_install_accelerator</A>
<LI><A HREF="gtk.html#IDX664">gtk_widget_intersect</A>
<LI><A HREF="gtk.html#IDX650">gtk_widget_map</A>
<LI><A HREF="gtk.html#IDX663">gtk_widget_popup</A>
<LI><A HREF="gtk.html#IDX652">gtk_widget_realize</A>
<LI><A HREF="gtk.html#IDX660">gtk_widget_remove_accelerator</A>
<LI><A HREF="gtk.html#IDX662">gtk_widget_reparent</A>
<LI><A HREF="gtk.html#IDX667">gtk_widget_restore_state</A>
<LI><A HREF="gtk.html#IDX668">gtk_widget_set_name</A>
<LI><A HREF="gtk.html#IDX671">gtk_widget_set_parent</A>
<LI><A HREF="gtk.html#IDX670">gtk_widget_set_sensitive</A>
<LI><A HREF="gtk.html#IDX669">gtk_widget_set_state</A>
<LI><A HREF="gtk.html#IDX672">gtk_widget_set_style</A>
<LI><A HREF="gtk.html#IDX673">gtk_widget_set_uposition</A>
<LI><A HREF="gtk.html#IDX674">gtk_widget_set_usize</A>
<LI><A HREF="gtk.html#IDX648">gtk_widget_show</A>
<LI><A HREF="gtk.html#IDX658">gtk_widget_size_allocate</A>
<LI><A HREF="gtk.html#IDX657">gtk_widget_size_request</A>
<LI><A HREF="gtk.html#IDX651">gtk_widget_unmap</A>
<LI><A HREF="gtk.html#IDX653">gtk_widget_unrealize</A>
<LI><A HREF="gtk.html#IDX691">gtk_window_add_accelerator_table</A>
<LI><A HREF="gtk.html#IDX685">gtk_window_get_type</A>
<LI><A HREF="gtk.html#IDX686">gtk_window_new</A>
<LI><A HREF="gtk.html#IDX693">gtk_window_position</A>
<LI><A HREF="gtk.html#IDX692">gtk_window_remove_accelerator_table</A>
<LI><A HREF="gtk.html#IDX689">gtk_window_set_default</A>
<LI><A HREF="gtk.html#IDX688">gtk_window_set_focus</A>
<LI><A HREF="gtk.html#IDX690">gtk_window_set_policy</A>
<LI><A HREF="gtk.html#IDX687">gtk_window_set_title</A>
<LI><A HREF="gtk.html#IDX121">GtkButton::clicked</A>
<LI><A HREF="gtk.html#IDX122">GtkButton::enter</A>
<LI><A HREF="gtk.html#IDX123">GtkButton::leave</A>
<LI><A HREF="gtk.html#IDX119">GtkButton::pressed</A>
<LI><A HREF="gtk.html#IDX120">GtkButton::released</A>
<LI><A HREF="gtk.html#IDX140">GtkCheckMenuItem::toggled</A>
<LI><A HREF="gtk.html#IDX197">GtkContainer::add</A>
<LI><A HREF="gtk.html#IDX201">GtkContainer::focus</A>
<LI><A HREF="gtk.html#IDX200">GtkContainer::foreach</A>
<LI><A HREF="gtk.html#IDX199">GtkContainer::need_resize</A>
<LI><A HREF="gtk.html#IDX198">GtkContainer::remove</A>
<LI><A HREF="gtk.html#IDX216">GtkCTree::tree_collapse</A>
<LI><A HREF="gtk.html#IDX215">GtkCTree::tree_expand</A>
<LI><A HREF="gtk.html#IDX217">GtkCTree::tree_move</A>
<LI><A HREF="gtk.html#IDX218">GtkCTree::tree_select_row</A>
<LI><A HREF="gtk.html#IDX219">GtkCTree::tree_unselect_row</A>
<LI><A HREF="gtk.html#IDX253">GtkEntry::activate</A>
<LI><A HREF="gtk.html#IDX251">GtkEntry::changed</A>
<LI><A HREF="gtk.html#IDX250">GtkEntry::delete_text</A>
<LI><A HREF="gtk.html#IDX249">GtkEntry::insert_text</A>
<LI><A HREF="gtk.html#IDX252">GtkEntry::set_text</A>
<LI><A HREF="gtk.html#IDX313">GtkInputDialog::disable_device</A>
<LI><A HREF="gtk.html#IDX312">GtkInputDialog::enable_device</A>
<LI><A HREF="gtk.html#IDX317">GtkItem::deselect</A>
<LI><A HREF="gtk.html#IDX316">GtkItem::select</A>
<LI><A HREF="gtk.html#IDX318">GtkItem::toggle</A>
<LI><A HREF="gtk.html#IDX329">GtkList::select_child</A>
<LI><A HREF="gtk.html#IDX328">GtkList::selection_changed</A>
<LI><A HREF="gtk.html#IDX330">GtkList::unselect_child</A>
<LI><A HREF="gtk.html#IDX365">GtkMenuItem::activate</A>
<LI><A HREF="gtk.html#IDX377">GtkMenuShell::deactivate</A>
<LI><A HREF="gtk.html#IDX524">GtkToggleButton::toggled</A>
<LI><A HREF="gtk.html#IDX622">GtkWidget::button_press_event</A>
<LI><A HREF="gtk.html#IDX623">GtkWidget::button_release_event</A>
<LI><A HREF="gtk.html#IDX632">GtkWidget::configure_event</A>
<LI><A HREF="gtk.html#IDX625">GtkWidget::delete_event</A>
<LI><A HREF="gtk.html#IDX626">GtkWidget::destroy_event</A>
<LI><A HREF="gtk.html#IDX642">GtkWidget::drag_begin_event</A>
<LI><A HREF="gtk.html#IDX613">GtkWidget::draw</A>
<LI><A HREF="gtk.html#IDX615">GtkWidget::draw_default</A>
<LI><A HREF="gtk.html#IDX614">GtkWidget::draw_focus</A>
<LI><A HREF="gtk.html#IDX641">GtkWidget::drop_event</A>
<LI><A HREF="gtk.html#IDX630">GtkWidget::enter_notify_event</A>
<LI><A HREF="gtk.html#IDX621">GtkWidget::event</A>
<LI><A HREF="gtk.html#IDX627">GtkWidget::expose_event</A>
<LI><A HREF="gtk.html#IDX633">GtkWidget::focus_in_event</A>
<LI><A HREF="gtk.html#IDX634">GtkWidget::focus_out_event</A>
<LI><A HREF="gtk.html#IDX608">GtkWidget::hide</A>
<LI><A HREF="gtk.html#IDX619">GtkWidget::install_accelerator</A>
<LI><A HREF="gtk.html#IDX628">GtkWidget::key_press_event</A>
<LI><A HREF="gtk.html#IDX629">GtkWidget::key_release_event</A>
<LI><A HREF="gtk.html#IDX631">GtkWidget::leave_notify_event</A>
<LI><A HREF="gtk.html#IDX609">GtkWidget::map</A>
<LI><A HREF="gtk.html#IDX635">GtkWidget::map_event</A>
<LI><A HREF="gtk.html#IDX624">GtkWidget::motion_notify_event</A>
<LI><A HREF="gtk.html#IDX643">GtkWidget::other_event</A>
<LI><A HREF="gtk.html#IDX637">GtkWidget::property_notify_event</A>
<LI><A HREF="gtk.html#IDX611">GtkWidget::realize</A>
<LI><A HREF="gtk.html#IDX620">GtkWidget::remove_accelerator</A>
<LI><A HREF="gtk.html#IDX638">GtkWidget::selection_clear_event</A>
<LI><A HREF="gtk.html#IDX640">GtkWidget::selection_notify_event</A>
<LI><A HREF="gtk.html#IDX639">GtkWidget::selection_request_event</A>
<LI><A HREF="gtk.html#IDX607">GtkWidget::show</A>
<LI><A HREF="gtk.html#IDX617">GtkWidget::size_allocate</A>
<LI><A HREF="gtk.html#IDX616">GtkWidget::size_request</A>
<LI><A HREF="gtk.html#IDX618">GtkWidget::state_changed</A>
<LI><A HREF="gtk.html#IDX610">GtkWidget::unmap</A>
<LI><A HREF="gtk.html#IDX636">GtkWidget::unmap_event</A>
<LI><A HREF="gtk.html#IDX612">GtkWidget::unrealize</A>
<LI><A HREF="gtk.html#IDX683">GtkWindow::move_resize</A>
<LI><A HREF="gtk.html#IDX684">GtkWindow::set_focus</A>
</DIR>

</P>



<H1><A NAME="SEC418" HREF="gtk_toc.html#TOC418">Concept Index</A></H1>

<P>
<H2>c</H2>
<DIR>
<LI><A HREF="gtk.html#IDX8">class</A>
<LI><A HREF="gtk.html#IDX4">Copying</A>
</DIR>
<H2>o</H2>
<DIR>
<LI><A HREF="gtk.html#IDX719">Object Implementation</A>
<LI><A HREF="gtk.html#IDX5">Overview</A>
</DIR>
<H2>s</H2>
<DIR>
<LI><A HREF="gtk.html#IDX720">Signal Implementation</A>
<LI><A HREF="gtk.html#IDX44">Signals</A>
</DIR>
<H2>t</H2>
<DIR>
<LI><A HREF="gtk.html#IDX6">type</A>
<LI><A HREF="gtk.html#IDX7">type system</A>
</DIR>
<H2>u</H2>
<DIR>
<LI><A HREF="gtk.html#IDX718">Using GTK</A>
</DIR>
<H2>w</H2>
<DIR>
<LI><A HREF="gtk.html#IDX721">Widget Implementation</A>
<LI><A HREF="gtk.html#IDX66">Widgets</A>
</DIR>

</P>

<P><HR><P>
This document was generated on 24 March 1999 using the
<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
translator version 1.54.</P>
</BODY>
</HTML>
